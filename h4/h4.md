# h4 Totally Legit Certificate

Tehtävien tekemiseen käytettiin pöytäkonetta:

- Prosessori: AMD Ryzen 5 3600 6-Core Processor 3.59 GHz
- Kovalevy: 256 GB M.2 SSD, 512 GB SSD
- Muisti: 32GB RAM
- Käyttöjärjestelmä: Windows 10 Pro
- VirtualBox

Lisäksi virtuaalikonetta: Kali Linux (valmis paketti, oletusasetuksilla)

Tarkemmat tehtävänannot osoitteessa: *[terokarvinen.com](https://terokarvinen.com/2023/eettinen-hakkerointi-2023/#h4-totally-legit-sertificate)*

## x) Lue/katso ja tiivistä.

OWASP 2021: OWASP Top 10:2021: A01:2021 – Broken Access Control (IDOR ja path traversal ovat osa tätä)
- periaatteena, että käyttäjät eivät voi toimia käyttöoikeuksiensa ulkopuolella
- epäonnistuminen voi johtaa luvattomaan tiedonsaantiin, tiedon muokkaamiseen tai tuhoamiseen, tai liiketoimintaan liittyvien toimintojen suorittamiseen ilman valtuutusta
- tyypillisiä haavoittuvuuksia mm. toimintaperiaatteen laiminlyöminen (käyttäjille ei jaettu rooleja, vaan laajemmat oikeudet automaattisesti kaikilla), oikeuksien sivuuttaminen muokkaamalla esim. URL:a (parametrien peukalointi)
- muutama esimerkki, miten ehkäistä:
    - sisäänpääsyn valvonnan tekniikoiden toteutus ja hyödyntäminen uudelleen verkkosovelluksen koko elinkaaren aikana
    - verkkopalvelimen hakemistolistausten estäminen
    - varmistus, että versionhallinta (esim. .git) ja varmuuskopiointi ei löydy verkkopalvelun juuresta (root)
    - rajapinnan pyyntöjen määrän rajoitus

*[OWASP - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)*

OWASP 2021: OWASP Top 10:2021: A10:2021 – Server-Side Request Forgery (SSRF)
- tapahtuu, kun verkkosovellus noutaa resursseja etälähteestä validoimatta käyttäjän syöttämää URL:a\
    &rarr; mahdollistaa hyökkääjän pakottamaan sovelluksen lähettämään tekaistun pyynnön odottamattomaan kohteeseen, vaikka käytössä olisi palomuuri tai VPN
- muutama esimerkki, miten ehkäistä:
    - verkkokerroksessa esim. verkkojen segmentointi erillisiksi, jotta vapaata liikkumista voidaan estää jonkun sisään murtautuessa
    - palomuurilla rajattu kaikki ulkopuolinen verkkoliikenne, pakollista sisäverkossa tapahtuvaa liikennettä lukuunottamatta
    - sovelluskerroksessa kaiken asiakasohjelman syöttödatan siistiminen ja validoiminen
    - HTTP uudelleenohjausten estäminen

*[OWASP - Serve-Side Request Forgery](https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/)*

PortSwigger Academy:

Access control vulnerabilities and privilege escalation (IDOR on osa tätä):
- määrittelee, mikäli käyttäjällä on oikeus aikomansa toiminnon suorittamiseen
- voidaan jakaa eri alakategorioihin: vertical access controls, horizontal access controls ja context-dependent access controls
- pystysuorassa mallissa (vertical) pääsynhallinta arkaluontoisiin toimintoihin on rajattu tietyntyyppisille käyttäjille (pääkäyttäjä vs. tavallinen käyttäjä)\
  &rarr; haavoittuvuus: esim. `https://example.com/admin` polkuun onkin tavallisella käyttäjällä selailumahdollisuus\
  &rarr; haavoittuvuus: jotkut sovellukset määrittelevät käyttäjän roolin ja varastoivat sen piilotettuun kenttään, evästeeseen tai esiasetettuun kyselyparametriin, jota voi manipuloida: `https://example.com/login/home.jsp?admin=true`
- vaakasuorassa mallissa (horizontal) pääsynhallinta on rajattu tiettyjen käyttäjien resursseihin (esim. pankkisovellus, jossa rahaa voidaan siirtää vain omilta tileiltä, ei toisen käyttäjän)\
  &rarr; haavoittuvuus: käyttäjä voi katsella esim. omia pankkitietojaan käyttäen osoitetta `https://example.com/myaccount?id=123`, tässä `id` voidaan muuttaakin toisen käyttäjän arvoksi, jolla päästään sisään toisen pankkitietoihin
- asiayhteyteen sidotussa mallissa (context-dependent) pääsynhallinta on rajattu toiminallisuuksiin ja resursseihin, jotka perustuvat sovelluksen tilaan tai miten käyttäjä 
on vuorovaikutuksessa sen kanssa (esim. toimintojen tekeminen väärässä järjestyksessä ei onnistu, maksettua tuotetta ei pysty enää muokkaamaan)

*[Portswigger - Access Control](https://portswigger.net/web-security/access-control)*

Server-side template injection
- ...

Server-side request forgery (SSRF)
- tyypillisessä hyökkäyksessä hyökkääjä saattaa saada palvelimen luomaan yhteyden yrityksen infran sisäisiin palveluihin
- esim. kun verkkosivulta tehdään pyyntö tarkastella jonkin tuotteen varastosaldoa, palvelin lähettää pyyntöjä eri back-end REST rajapintoihin\
  &rarr; POST-pyyntöä voidaankin muokata `stockApi=http://localhost/admin`\
  &rarr; nyt pyyntö tulee paikalliselta koneelta, joten sovellus antaakin pääkäyttäjäoikeudet luotettuaan pyynnön lähteeseen\
  &rarr; jos paikallisen koneen pyyntöjä kohdellaan eri tavoin kuin normaaleja pyyntöjä, SSRF muuttuu kriittiseksi haavoittuvuudeksi

*[Portswigger - Server-side Request Forgery](https://portswigger.net/web-security/ssrf)*

Cross-site scripting
- usein injektoidaan payload, joka aikaansaa oman selaimen suorittamaan satunnaista/mielivaltaista Javascript-koodia.
- esim. ```alert()``` funktio on ollut pitkään käytössä -> lyhyt, harmiton ja vaikea ohittaa, kun kutsutaan oikein
- Chrome estänyt versiosta 92 alkaen, joten käytössä myös ```print()```
- 3 eri tyyppiä: reflected (haitallinen skripti tulee sen hetkisestä HTTP-pyynnöstä), stored (haitallinen skripti tulee verkkosivun tietokannasta), DOM-based (haavoittuvuus sijaitsee client-puolen koodissa palvelimen sijaan)

*[Portswigger - Cross-site Scripting](https://portswigger.net/web-security/cross-site-scripting)*

Karvinen 2020: Using New Webgoat 2023.4 to Try Web Hacking:
- sovellus, jolla voidaan harjoitella tunkeutumistestausta
- javan asennus mahdollistaa käytön, palomuurin asennus suojaksi
- Webgoat:n viimeisin versio löytyy GitHub:sta
- mikäli käytössä välimiesproxy, hyvä muuttaa portiksi joku toinen ennen käynnistämistä, esim. 8081

## a) Totally Legit Sertificate. Asenna OWASP ZAP, generoi CA-sertifikaatti ja asenna se selaimeesi. Laita ZAP proxyksi selaimeesi. Osoita, että hakupyynnöt ilmestyvät ZAP:n käyttöliittymään. (Ei toimi localhost:lla ilman Foxyproxya)

Maanantain tunnilla kävimme nopeasti Zap:n lataamisen läpi, mutta lukaisin *[getting started -ohjeita](https://www.zaproxy.org/getting-started/)* asennuksesta. Muistelin, että Zap vaatii Javan pyöriäkseen. Dokumentaatiosta selvisikin, että Linux:lle pitää asentaa Java +11 erikseen. Aloitin ensin kalin pakettien päivityksillä ja latasin Zap:n Linux paketin (Huomasin tosin myöhemmin Teron vinkit, jossa mainittiin cross-platformin olevan paras vaihtoehto).

![zap_package](https://github.com/jjenska/PenTest/assets/105623785/63777b0b-b81c-4a82-81b6-e2feb0dd587b)



Tämän jälkeen etsin ladattavaa Javaa tunnilla käydyn ohjeen perusteella:

```console
┌──(kali㉿kali)-[~]
└─$ apt-cache search jdk jre
default-jre - Standard Java or Java compatible Runtime
default-jre-headless - Standard Java or Java compatible Runtime (headless)
libanimal-sniffer-java - JDK/API verification tools
libhsdis0-fcml - HotSpot disassembler plugin using FCML
libreoffice - office productivity suite (metapackage)
openjdk-11-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-11-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-11-jre-zero - Alternative JVM for OpenJDK, using Zero
openjdk-17-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-17-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-17-jre-zero - Alternative JVM for OpenJDK, using Zero
openjdk-21-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-21-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-21-jre-zero - Alternative JVM for OpenJDK, using Zero
openjdk-22-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-22-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-22-jre-zero - Alternative JVM for OpenJDK, using Zero
java-package - Utility for creating Java Debian packages
nvidia-openjdk-8-jre - Obsolete OpenJDK Java runtime, for NVIDIA applications
```

Valitsin openjdk-17-jre, joka käytiin läpi tunnin esimerkissäkin. Oletukseni oli, että se on vakaampi versio, kuin uudemmat 21/22.

```console
┌──(kali㉿kali)-[~]
└─$ sudo apt-get install openjdk-17-jre
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages were automatically installed and are no longer required:
  gcc-12-base libarmadillo11 libcanberra-gtk-module libcanberra-gtk0 libcbor0.8 libcodec2-1.1 libcurl3-nss
  libgcc-12-dev libgumbo1 libgupnp-igd-1.0-4 libjim0.81 libnfs13 libobjc-12-dev libstdc++-12-dev libtexluajit2
  libutf8proc2 libvpx7 lua-lpeg nss-plugin-pem python3-jdcal python3-pyminifier
Use 'sudo apt autoremove' to remove them.
The following additional packages will be installed:
  openjdk-17-jre-headless
Suggested packages:
  fonts-ipafont-gothic fonts-ipafont-mincho fonts-wqy-microhei | fonts-wqy-zenhei fonts-indic
The following packages will be upgraded:
  openjdk-17-jre openjdk-17-jre-headless
2 upgraded, 0 newly installed, 0 to remove and 63 not upgraded.
Need to get 43.9 MB of archives.
After this operation, 33.8 kB disk space will be freed.
Do you want to continue? [Y/n] y
Get:1 <http://http.kali.org/kali kali-rolling/main> amd64 openjdk-17-jre amd64 17.0.9+9-2 [184 kB]
Get:2 <http://http.kali.org/kali kali-rolling/main> amd64 openjdk-17-jre-headless amd64 17.0.9+9-2 [43.7 MB]
Fetched 43.9 MB in 2s (18.6 MB/s)                   
(Reading database ... 409376 files and directories currently installed.)
Preparing to unpack .../openjdk-17-jre_17.0.9+9-2_amd64.deb ...
Unpacking openjdk-17-jre:amd64 (17.0.9+9-2) over (17.0.9+9-1) ...
Preparing to unpack .../openjdk-17-jre-headless_17.0.9+9-2_amd64.deb ...
Unpacking openjdk-17-jre-headless:amd64 (17.0.9+9-2) over (17.0.9+9-1) ...
Setting up openjdk-17-jre-headless:amd64 (17.0.9+9-2) ...
Processing triggers for mailcap (3.70+nmu1) ...
# ...
# poistettu useita rivejä
```
Asennus todennäköisesti onnistui, koska en saanut virheitä. Sen jälkeen lähdin asentamaan ZAP:a. Piti hieman muistella tar-tiedoston purkamista, mutta h2 tehtävässä ffuf:n asennus tapahtui samalla kaavalla. Komennossa siis ```-x``` tarkoittaa ```execute```, eli suorita. ```-f``` taas määrittelee tiedoston (file), jonka tiedot lisätään viimeiseksi (ZAP_2.1.14.0_Linux.tar.gz).

```console
┌──(kali㉿kali)-[~/Downloads]
└─$ tar -xf ZAP_2.14.0_Linux.tar.gz 
┌──(kali㉿kali)-[~/Downloads]
└─$ ls
ZAP_2.14.0  ZAP_2.14.0_Linux.tar.gz
```
Loin vielä oman kansion Zap, jonka jälkeen siirsin purkamani tiedoston sinne.

```console
┌──(kali㉿kali)-[~/Downloads]
└─$ cd ..
┌──(kali㉿kali)-[~]
└─$ mkdir Zap 
┌──(kali㉿kali)-[~]
└─$ mv Downloads/ZAP_2.14.0 Zap 
```

Tämän jälkeen siirryin Zap-kansioon ja vilkaisin, mitä tiedostoja se sisältää. Päätin lukaista nopeasti README-tiedoston. Siellä oli tieto, että Zap voidaan käynnistää "zap.sh" tai esim. luoda graafinen pikakuvake sovellukselle. Testasin toimiiko ajo suoraan: ./zap.sh. Ohjelma avautui ruudulle, ja hetken ladattuaan avasi kysymysboksin: "Do you want to persist the ZAP session?". Dokumentaation mukaan Zap oletusarvoisesti tallentaa liikennettä levylle HSQLDB tietokantaan oletusnimellä ja sijainnilla. Mikäli istuntoa ei pidetä yllä (persist), tiedostot poistetaan, kun käyttäjä poistuu ZAP:sta. Vaihtoehtona olisi myös tallentaa istunnot valitsemaansa sijaintiin. Valitsin "No, I do not want to persist this session at this moment in time", jota dokumentaatio suositteli näin alkuvaiheessa, kun käyttö on uutta. Tämän jälkeen "start".

![option_no](https://github.com/jjenska/PenTest/assets/105623785/4eecf053-d9b8-40ee-abb1-fdc5afbf50a4)

Tämän jälkeen sain listan ZAP:n lisäosista ja mahdollisuuden päivittää niitä. En ollut varma, onko näillä merkitystä? Painoin tässä vaihessa "Close". 

![addons](https://github.com/jjenska/PenTest/assets/105623785/1a86e1fc-07b2-4da1-b794-02f655ee48c1)

Sitten lähdin luomaan sertifikaattia. Valitsin ZAP:n ylävalikosta
 
"Tools" -> kirjoitin hakukenttään "certificate" -> löytyi välilehdeltä "Network" -> "Server Certificates" -> "Generate"

Tämä avasi uuden ikkunan, joka ilmoitti että Root CA on jo olemassa. Painoin kuitenkin, että haluan ylikirjoittaa nykyisen sertifikaatin. "Yes".

![certf](https://github.com/jjenska/PenTest/assets/105623785/7e44469c-422d-4234-8b89-b1bf62caba37)

Tämän jälkeen klikkasin "Save", ja valitsin hakemistostani kansion Zap, jonne tallensin "Save". 

![savecertf](https://github.com/jjenska/PenTest/assets/105623785/ec0ff7e6-a28b-46ca-b2ff-673fc299da65)

Vielä kaiken varmistuksena klikkasin "ok". Tämän jälkeen navigoin Firefoxiin, ja oikealta ylhäältä valikosta "Settings". Hakukenttään syötin "certificate", jonka jälkeen klikkasin "View Certificates".

![certfs](https://github.com/jjenska/PenTest/assets/105623785/001bc048-1e4b-4c7e-b8fc-40ef2deb648b)

Sieltä klikkasin "import" ja valitsin hakemiston, jossa tallentamani sertifikaatti sijaitsi. Sen jälkeen "Open". Tässä vaiheessa Firefox kysyi, että haluanko luottaa: YES ensimmäiseen.

![trust](https://github.com/jjenska/PenTest/assets/105623785/be1d03d8-a228-46a3-a3a0-6be4a206dd2b)

Tämän jälkeen sertifikaatti ilmestyi listalle, klikkasin vielä "ok.".

![certok](https://github.com/jjenska/PenTest/assets/105623785/4452c259-ac68-4cdf-8ecb-1fd87a193197)

Tämän jälkeen testasin sertifikaatin toiminnan avaamalla Firefoxin ja Googlen. Näytti täysin luotettavalta:

![toimii](https://github.com/jjenska/PenTest/assets/105623785/ee15ef35-af0b-45bb-a1b3-ab7e314b730f)

Kirjoitin Googleen hakusanaksi "kokeilu", jolla testasin listautuuko GET-pyyntö ZAP:iin. Liikenne näytti toimivan oikein.

<img src="https://github.com/jjenska/PenTest/assets/105623785/495b9971-2272-46ea-b1af-3299242cc1b7" width="600" height="300" />


## b) Asenna FoxyProxy Standard Firefox Addon, ja lisää ZAP proxyksi siihen.

Avasin Firefoxin ja klikkasin oikealta ylhäältä lisäosien kuvaketta, ja hain hakusanalla foxyproxy. 

![foxyproxy](https://github.com/jjenska/PenTest/assets/105623785/d665fbaf-6c5f-4d0f-a2e2-d9a1d26b86e3)

Suosituksena löytyi Foxyproxy standard, joten klikkasin sen kohdalla "Add to Firefox". Kun klikkasi selaimen osoiterivin oikealla puolella, ylhäällä olevaa lisäosakuvaketta ja asetuspainiketta, sai kiinnitettyä foxyproxin osoitepalkkiin näkyviin. Sitten klikkasin foxyproxy-kuvaketta, josta "Options" -> "Add". Tunnilla käytiin asetukset pikaisesti läpi, mutta silmäilin vielä Sami Kulonpään aikaisemman kurssitoteutuksen *[ohjeita](https://kulonpaa.com/?p=338)*.

![addfp](https://github.com/jjenska/PenTest/assets/105623785/c2f7aba6-1103-44c5-8ce6-2ce1eca790a4)

Proxyn tyyppinä oli valmiiksi "HTTP", annoin sen olla, koska tulevat tehtävät käsittelisivät verkkosovellushyökkäyksiä. Tyypin alle pystyi laittamaan joko IP-osoitteen tai nimipalvelujärjestelmän nimen, eli itse lisäsin vain "localhost" -nimellä. Portiksi määrittelin 8080, ja loput vaihtoehdot olivatkin vapaaehtoisia. Tämän jälkeen painoin "Save". Päätin kuitenkin lisätä proxyn nimeksi vielä ZAP, mikäli päätyisin käyttämään myös Burp Suite:a tehtävien teossa. Tämän jälkeen otin proxyn käyttöön:

![zapurls](https://github.com/jjenska/PenTest/assets/105623785/1b5c7fe3-0362-4952-be90-10a2f333f988)

## PortSwigger Labs. Ratkaise tehtävät. Selitä ratkaisusi: mitä palvelimella tapahtuu, mitä eri osat tekevät, miten hyökkäys löytyi, mistä vika johtuu.

### Insecure Direct Object Reference (IDOR)
#### c) Insecure direct object references

Ensimmäisessä tehtävässä oli tarkoitus katsella käyttäjän chat-logeja palvelimen tiedostoissa, ja saada ne haltuun käyttämällä staattista URL:a. Tehtävä meni aikalailla ZAP:n käyttöä harjoitellen, ja kuvakaappaukset eri vaiheista unohtuivat täysin. Tehtävässä kaappasin pyynnön ZAP:ssä samalla, kun klikkasin "live chat" välilehdeltä löytyvää "View transcript" painiketta. URL:sta paljastui "2.txt"-tiedosto. Tähän en pähkäiltyäni keksinyt itse ratkaisua, vaan jouduin vilkaisemaan tehtävänannosta polkua. Tiedoston numeroinnista olisi pitänyt tajuta, että kun manipuloi numeron 2 -> 1, saadaan kopio aikaisemmasta keskustelusta. Kun suoritin pyyntöön muokkauksen "1.txt", sain tiedostosta auki chatissä käydyn keskustelun, jossa Carlosin salasananvahvistustiedustelu vahvistettiin. 

![carlos](https://github.com/jjenska/PenTest/assets/105623785/610142eb-2e6d-4605-be0a-b2e85ab0e1b8)

Yritän päivittää tehtävän vielä uudelleen kuvien kanssa, jos ehdin.

### Path traversal
#### d) File path traversal, simple case

Tässä tehtävässä oli tarkoitus hyödyntää haavoittuvuutta tiedostopolussa, kun tarkastellaan tuotekuvia. Päämääränä oli päästä ```/etc/passwd``` hakemistoon. Aloitin labran kaappaamalla ZAP:lla HTTP-liikenteen. Sitten klikkasin sivulla olevan tuotteen lisätietoja, ja latasin avautuvan kuvan erilliseen välilehteen. Tämä vaihe menikin harjoittelun piikkiin, koska pyyntöjä olisi voinut ohjata eteenpäin järjestyksessä, jolloin haluttu pyyntö olisi tullut vastaan. ZAP:ssa GET-pyyntö näytti joka tapauksessa tältä:

![filepath](https://github.com/jjenska/PenTest/assets/105623785/9755e14b-1bdb-4a63-bfbc-81bb91364ac4)

Punainen nappula ylhäällä näytti, että pyyntö on pysäytettynä. Kuvan polussa näkyi ```image?filename=26.jpg```. Olin törmännyt kotitehtävässä h3 vastaavankaltaiseen esimerkkiin. Tiesin siis, että polkua voidaan manipuloida lisäämällä parametrin "filename" perään ```../../../etc/passwd```. Oletuspolku levylle talletetuissa kuvissa on ```/var/www/images```. Palauttaakseen kuvan, sovellus lisää tämän tiedostonimen tuohon oletuspolkuun, eli lukee tässä tapauksessa ```/var/www/images/26.jpg```. Loppuliitteessä ```../../../``` kuvastaa hakemistossa siirtymistä alhaalta ylöspäin juureen *([Portswigger- File Path Traversal](https://portswigger.net/web-security/file-path-traversal))*. Eli ensin images -> www -> var -> /, josta etc -> passwd.

![donefilepath](https://github.com/jjenska/PenTest/assets/105623785/8c85ef43-cbdf-48ac-a7a6-3c0ebe0fd456)

Tämän jälkeen klikkasin ZAP:ssä pysäytyspainikkeen vieressä olevaa "play" painiketta, joka ohjasi muokatun pyynnön eteenpäin, ja näin labra oli ratkaistu. Tehtävien teko päättyi tiistaina 14.11..

#### e) File path traversal, traversal sequences blocked with absolute path bypass

Jatkoin torstaina 16.11. siitä mihin olin jäänyt viimeksi. Vaihdoin välimiesproxyn Burb:iin ja kirjauduin Portswiggerin sivuille. Huomasin kuitenkin, että "Access the lab" painike oli hävinnyt kokonaan. Luulin ensin, että kyse on siitä, että ratkaisin tehtävän jo, mutta se ei ilmestynytkään mihinkään labraan. 

![problem](https://github.com/jjenska/PenTest/assets/105623785/670a620d-7f91-4481-9f97-2cd5c4d91f3d)

Kokeilin avata sivuston eri selaimilla (Firefox, Chromium, Chrome), mutta mikään ei tuottanut tulosta. Tein myös toisen käyttäjätilin testiksi, mutta sama ongelma toistui. Löysin aikaisemman viestiketjun, jossa muillakin käyttäjillä oli ongelmia, syy ei ollut tosin selvinnyt. Päätin laittaa sivustolle sähköpostia, koska en löytäny mitään muuta tietoa. Tässä vaiheessa siirryin asentamaan WebGoat:a, jotta aikaa ei menisi hukkaan. Testasin uudelleen iltapäivällä, noin parin tunnin kuluttua kirjautua uudelleen, ja nyt painikkeet olivat palanneet. Sain myöhemmin sähköpostin, jossa ilmoitettiin labran olleen huollon alla, selvisi siis syykin.

Jatkoin tehtäviä torstaina illalla. Tässä vaiheessa olin siis siirtynyt Zap:n sijasta käyttämään Burp Suite:a. Tehtävässä oli haavoittuvuus tuotekuvan tiedostopolussa. Verkkosovellus estää poikittaiset tiedostopolut, mutta tiedostonimi on suhteessa normaaliin hakemistoon. Täytyi saada selvitettyä ```/etc/passwd``` tiedoston tiedot. Kaappasin Burp:ssa liikenteen ja klikkasin yhden tuotteen tietoja Portswiggerin verkkosovelluksessa.

![patht1](https://github.com/jjenska/PenTest/assets/105623785/4c1e1c50-a7c0-498d-8eb1-7344f90e8e65)

Ylhäällä pyynnössä näkyi ```GET /image?filename=30.jpg```. Tätä lähdin muuttamaan suoraan poluksi ```GET /image?filename=etc/passwd```:

![path2](https://github.com/jjenska/PenTest/assets/105623785/bc30fefc-d924-4821-86a8-b01f01610364)

Siirsin pyynnön muokattuna eteenpäin. Avasin taas HTTP-liikenteen normaaliksi, ja Portswiggerin sivulle ilmestyi, että labra on suoritettu. Minulta oli kuitenkin jäänyt pyynnön vastauksen kuvakaappaus nappaamatta.  

#### f) File path traversal, traversal sequences stripped non-recursively

Tehtävässä oli haavoittuvuus tuotteiden kuvissa, kuten aikaisemmissa tehtävissä. Verkkosovellus poistaa tiedostopolun järjestyksen käyttäjän tarjoamasta tiedostonimestä ennen sen käyttämistä. Tässä piti löytää myös ```/etc/passwd``` tiedosto. Portswiggerin *[infosta](https://portswigger.net/web-security/file-path-traversal)* löytyi vinkki tehtävän ratkaisemiseen. Tässä voisi käyttää nk. "nested" tiedostopolkua ```....//....//```. Tässä tapauksessa verkkosovellus poistaisi polun, mutta koska se on tuplana, jäljelle jää edelleen ```../../```. 

Avattuani labran, klikkasin Burp:sta "intercept on", ja valitsin verkkosovelluksen tuotteista ensimmäisen. Lähetin pyyntöjä eteenpäin niin kauan, että sain GET-pyynnön, jossa näkyy tiedostopolku ```/image?filename=```. Tämän pyynnön nappasin repeater-toimintoon, ja vapautin HTTP-liikenteen. Tiedostopoluksi muokkasin nyt ```/image?filename=....//....//....//etc/passwd```. Sen jälkeen "Send" ja vastaus näytti lupaavalta:

![pathnon1](https://github.com/jjenska/PenTest/assets/105623785/08b4f262-da31-4395-90b7-47b0b85e4061)

Tehtävä oli ratkaistu.

### Server Side Template Injection (SSTI)
#### g) Server-side template injection with information disclosure via user-supplied objects (Tämä on merkitty hieman vaikeammaksi, jätä viimeiseksi jos näyttää hankalalta)

Tämän tehtävä jäi aikatauluhaasteiden vuoksi kokonaan suorittamatta.

### Server Side Request Forgery (SSRF)
#### h) Basic SSRF against the local server

Tehtävässä oli olemassa varastosaldojen tarkistusominaisuus, joka hakee dataa sisäisestä järjestelmästä. Tämä Stock check URL täytyi muuttaa admin näkymäksi osoitteessa ```http://localhost/admin```, sekä poistaa käyttäjä carlos. Klikkasin ensimmäistä verkkosivulla näkyvää tuotetta ja skrollasin alas, josta löytyi painike "Check Stock":

![Screenshot 2023-11-18 at 0 08 23](https://github.com/jjenska/PenTest/assets/105623785/b3c8a501-4269-427e-a620-9b627d8b573f)

Tässä vaiheessa kaappasin liikenteen Burp:lla, ja klikkasin kyseistä painiketta. Sain POST-pyynnössä stockApi-polun, jota voisi hyödyntää. 

![ssrfport1](https://github.com/jjenska/PenTest/assets/105623785/474cc1b3-9313-4149-bf14-e013d7f0b310)

Tässä tapauksessa kyseinen rajapinta luottaisi pyyntöön, joka tulee paikalliselta koneelta eli localhostilta. Kokeilin muuttaa polun tehtävässä annetuksi esimerkiksi, tämä avasikin vastauksena mielenkiintoista dataa. Kiinnostavia olivat polut ```/admin/delete?username=wiener``` ja ```/admin/delete?username=carlos```. 

![ssrfport2](https://github.com/jjenska/PenTest/assets/105623785/5a9e67d6-7426-46f3-9a3a-c7645beda3a8)

Koska tehtävässä pyydettiin poistamaan käyttäjä nimeltä carlos, vaihdoin API-poluksi ```http://localhost/admin/delete?username=carlos```. Näin pyyntö tuli paikalliselta koneelta, joten käyttäjän poistaminen voisi onnistua. Statuksena sain 302, eli pyynnön uudelleen ohjaus onnistui.

![ssrfport3](https://github.com/jjenska/PenTest/assets/105623785/6ab2d7fb-d072-4ead-90f7-3a6f5f89c091)

### Cross Site Scripting (XSS)
#### i) Reflected XSS into HTML context with nothing encoded

Tässä tehtävässä oli tarkoitus hyödyntää cross-site scriptingille haavoittunutta hakutoimintoa. Täytyi hyödyntää alert funktiota hyökkäyksen toteuttamiseen. Avasin labran, ja heti etusivulta löytyi hakukenttä. Kirjoitin siihen skriptin ```<script>alert('xss')</script>```. Tämän jälkeen kaappasin Burp:lla liikenteen, lähinnä mielenkiinnosta, miltä pyyntö näyttää. Klikkasin "Search".

![xss1](https://github.com/jjenska/PenTest/assets/105623785/7a355e1a-a3e4-49cb-a6d6-9b1defc2dd33)
![xss2](https://github.com/jjenska/PenTest/assets/105623785/31a98eb3-16fe-40c2-b44e-fd07feb679cd)

Siellä tuo näkyi injektoituna, vapautin liikenteen normaaliksi. Sen jälkeen hyökkäys näkyikin käytännössä ja tehtävä oli ratkaistu:

![xss3](https://github.com/jjenska/PenTest/assets/105623785/07894412-3641-4629-b0a8-43f60885ef9a)

#### j) Stored XSS into HTML context with nothing encoded

Tämä tehtävä sisälsi havoittuvuuden kommenttikentässä. Selvittääkseen tehtävän, täytyi palstalle lähettää kommentti, joka kutsuu alert funktiota, kun blogipostaus avataan. Kun labra aukesi, etusivulla näkyi lista blogipostauksia. Klikkasin ensimmäisen auki ja skrollasin alas kommentointiosioon. Kommenttiin kirjoitin yksinkertaisen skriptin ```<script>alert('xss')</script>```. Klikkasin "Post Comment", mutta lomake vaatikin nimen ja sähköpostin. Täytin arvot, jonka jälkeen kommentin lähetys onnistui.

![xsss1](https://github.com/jjenska/PenTest/assets/105623785/b6f5995f-2549-4720-9e55-c0dd41ec71d3)

Siirryin takaisin blogin etusivulle ja klikkasin postausta uudelleen. Tämä laukaisi alert funktion:

![xsss3](https://github.com/jjenska/PenTest/assets/105623785/4818d763-26c7-4d3f-8d38-013bff9fe10c)

Tehtävä oli ratkaistu.

## k) Asenna Webgoat 2023.4. (Uusi versio, jossa on eri tehtäviä kuin vanhemmissa)

Asennuksen tein Tero Karvisen *[ohjeita](https://terokarvinen.com/2023/webgoat-2023-4-ethical-web-hacking/)* mukaillen. Palomuurin olin jo asentanut Kalille, joten testasin, että se on toiminnassa:

```console
┌──(kali㉿kali)-[~]
└─$ sudo ufw status    
Status: active
```

WebGoat:n vaatima Javakin oli tullut asennettua jo ZAP:n asennuksen yhteydessä, joten siirryin lataamaan uusimman WebGoat version *[GitHub:sta](https://github.com/WebGoat/WebGoat/releases/tag/v2023.4)*. Klikkasin vain pakettia, ja tarkistin, että se ilmestyi ladattuihin tiedostoihin.

![downloadwebgoat](https://github.com/jjenska/PenTest/assets/105623785/cdaeff4c-1a48-45c8-8576-8c912272350d)

Koska WebGoat on tarkoituksella haavoittuvainen sovellus, kytkin koneen irti internetistä ja testasin ```ping 8.8.8.8```, jotta yhteys on varmasti poikki. Päädyin myös käyttämään Burp Suite:a, koska olin testannut sitä jo h3-kotitehtävässä. Ilmainen versio vaikutti sisältävän riittävästi ominaisuuksia, ja käyttöliittymä oli jo osittain tuttu. Burp kuuntelee myös oletuksena porttia 8080, joten jouduin muuttamaan sen asetukset. Avasin Burp:n ja klikkasin oikealta ylhäältä "Settings" -> "Tools" -> "Proxy".

![burpproxy](https://github.com/jjenska/PenTest/assets/105623785/f1e44e80-62bc-4a76-acf3-2f3f21ee3a86)

Sen jälkeen loin vielä Foxyproxy:lle Burp-proxyn, jonka IP 127.0.0.1 ja portiksi 8888. Otin proxyn käyttöön.

![burbzap](https://github.com/jjenska/PenTest/assets/105623785/657e6dfd-9254-46c0-a7ed-0d0701c33869)

Sitten siirryin käynnistämään WebGoat:n.

```console
┌──(kali㉿kali)-[~/Downloads]
└─$ java -Dfile.encoding=UTF-8 -Dwebgoat.port=8081 -Dwebwolf.port=9090 -jar webgoat-2023.4.jar
```
Ensimmäinen ```-Dfile.encoding=UTF-8``` oletettavasti määrittelee, millä merkistöllä java koodaa tiedostot? Seuraavat osat määrittelevät WebGoat:n ja WebWolf:n portit. Koska Zap oli minulla jo määritelty porttiin 8080, asetin WebGoat:lle portin 8081. WebWolf on *[OWASP:n mukaan](https://owasp.org/www-project-webgoat/)* erillinen verkkosovellus, joka imitoi hyökkääjän konetta. Se mahdollistaa erottamaan, mitä hyökättävällä verkkosivulla tapahtuu ja toiminnot, joita hyökkääjänä tarvitsee tehdä. Oletuksena se kuuntelee porttia 9090, mutta se oli myös määriteltävä WebGoat:n käynnistyksen yhteydessä. Komennon ajamisen jälkeen alkoi pitkä lista toimintoja:

```console
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
2023-11-16 12:18:20.472  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : Starting StartWebGoat v2023.4 using Java 17.0.9 on kali with PID 34706 (/home/kali/Downloads/webgoat-2023.4.jar started by kali in /home/kali/Downloads)
2023-11-16 12:18:20.477  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : No active profile set, falling back to 1 default profile: "default"
2023-11-16 12:18:20.966  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : Started StartWebGoat in 1.004 seconds (JVM running for 1.722)
    __          __       _        _____                   _
    \ \        / /      | |      / ____|                 | |
     \ \  /\  / /  ___  | |__   | |  __    ___     __ _  | |_
      \ \/  \/ /  / _ \ | '_ \  | | |_ |  / _ \   / _' | | __|
       \  /\  /  |  __/ | |_) | | |__| | | (_) | | (_| | | |_
        \/  \/    \___| |_.__/   \_____|  \___/   \__,_|  \__|

2023-11-16 12:18:21.180  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : No active profile set, falling back to 1 default profile: "default"
2023-11-16 12:18:22.411  INFO 34706 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2023-11-16 12:18:22.500  INFO 34706 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 79 ms. Found 2 JPA repository interfaces.
# jatkuu usean rivin verran, jonka jälkeen ilmoitus: please browse to http://127.0.0.1:8081/WebGoat to get started...
```
Avasin Firefoxin, ja navigoin osoitteeseen ```localhost:8081/WebGoat```. Sain etusivun aukeamaan, ja ryhdyin luomaan itselleni käyttäjätunnukset. 

![webgoatlogin](https://github.com/jjenska/PenTest/assets/105623785/b9eefb0d-4e5b-4868-ae16-204607c57ae6)

Käyttäjätunnus oli aluksi ohjeiden mukaan liian lyhyt (väh. 6 merkkiä), joten muokkasin sen kuntoon, jotta pääsin kirjautumaan sisään.

![webgoatfront](https://github.com/jjenska/PenTest/assets/105623785/58269692-5fec-4c26-9b1e-9e1e70b2ebaa)

## Ratkaise WebGoat 2023.4:

### m) (A1) Broken Access Control (WebGoat 2023.4)
#### Hijack a session (1)

Tämä tehtävä tuntui itselleni lähtökohtaisesti haastavalta, sillä en ollut perehtynyt evästeisiin tarkemmin. Tehtävänannossa annettiin pohjustus, että verkkosovelluksen käyttäjän istunnon ID:n tulisi olla tarpeeksi monimutkainen ja satunnainen. Mikäli näin ei ole, sovellus voi olla altis brute-force hyökkäyksille, jossa istunto on mahdollista kaapata. Tehtävän kenttiin täytyi syöttää käyttäjätunnus ja salasana, sekä klikata "Access" painiketta. 

![hijack1](https://github.com/jjenska/PenTest/assets/105623785/a7c00bfb-e6e0-4fc8-a486-187952d6ee5e)

Lähestyin tehtävää niin, että laitoin Burp:lla liikenteen kaappauksen päälle, syötin molempiin kenttiin "testuser" ja klikkasin painiketta. Tämän jälkeen siirsin pyynnön Burp:ssa "repeater" toimintoon, jossa pyynnön pystyy nimensä mukaisesti lähettämään useasti uudelleen, saaden vastauksen. HTTP-liikenteen kaappauksen otin pois päältä, ja tarkastelin hijack-numerosarjaa, joka vaihtui aina pyyntöjen välillä. 

![sessionID2](https://github.com/jjenska/PenTest/assets/105623785/08376f72-7df4-42d3-b947-3f21758f4d91)

Minulla ei ollut osaamista jatkaa, joten etsin verkosta, löytyisikö tehtävään jonkinlaista tutoriaalia. Löysinkin *[Youtubesta](https://www.youtube.com/watch?v=R5YPRhM5GyE)* perusteellisen läpikäynnin. Tutoriaalin avulla opin, että Burp:ssa on myös "sequencer" ominaisuus, jolla pystyy tallentamaan useita satoja-tuhansia istuntoja. Burp:n HTTP-historiasta nappasin oikean pyynnnön, klikkasin hiiren oikealla ja "send to sequencer". Tämän jälkeen varmistin, että listalla on oikea pyyntö, ja alhaalle valittuna pyynnössä oleva oikea sijainti. Nämä tiedot Burp täytti automaattisesti itse, mutta täytyi tarkistaa, että kaikki on oikein.

![sequencer](https://github.com/jjenska/PenTest/assets/105623785/2a637e36-241e-4c28-a77f-88b8eb25a3a4)

Tämän jälkeen klikkasin "Start live capture", joka alkoi raksuttaa nopealla tahdilla. Kun tokeneita oli saatu tarpeeksi, piti klikata ikkunassa olevaa nappia "Pause". Itse lopetin noin 1000 tokenin kohdalla, vaikka vähempikin olisi taatusti riittänyt. Ikkunasta löytyi myös painike "Save", jolla koko listan pystyi tallentamaan omaan tiedostoon.

![tokens](https://github.com/jjenska/PenTest/assets/105623785/0977379b-c9e9-433b-8155-10f9e7f0abc0)

Tämän jälkeen tutoriaali ohjeisti, että voi ajaa komentorivissä:

```console
┌──(kali㉿kali)-[~]
└─$ sort tokens   
1840833201636707492-1700134785787
1840833201636707491-1700134785785
1840833201636707498-1700134785820
1840833201636707501-1700134785878
1840833201636707502-1700134785895
1840833201636707504-1700134785910
1840833201636707506-1700134785920
1840833201636707507-1700134785929
1840833201636707508-1700134785939
1840833201636707510-1700134785950
1840833201636707512-1700134785961
1840833201636707513-1700134785967
1840833201636707515-1700134785974
1840833201636707516-1700134785982
1840833201636707517-1700134785989
1840833201636707519-1700134785996
# ...
# jatkuu monta riviä
```
Tämä listasi kaikki numerotiedot järjestykseen. Tarkoituksena oli etsiä numeroista poikkeavuuksia. Pikaisella tarkastelulla huomasi, että numerosarjan alkuosa oli hyvin samanlainen. Kolmannen viimeisen numeron kohdalla ennen väliviivaa, jokainen numero nousi järjestyksessä. Eli esimerkiksi 498:n kohdalla siirryttiin seuraavaan sataan 501. Myös väliviivan toisella puolella numeroista 3 viimeistä nousivat järjestyksessä. Tarkoituksena oli näiden avulla löytää kohtia, joiden välissä istunto voisi olla jo käytössä:

```js
1840833201636707513-1700134785967
// esim. tästä välistä puuttuu 514
1840833201636707515-1700134785974
1840833201636707516-1700134785982
```
Tutoriaalissa käytiin läpi myös Burp:sta löytyvä Intruder-ominaisuus, jonne pyyntö voitiin siirtää klikkaamalla HTTP-historiasta oikea pyyntö hiiren oikealla painikkeella ja "send to intruder". Tässä numerosarja muutettiin lopusta vastaamaan samaa 514-loppuista poikkeamaa. Lisäksi ominaisuus mahdollistaa väliviivan jälkeen tulevien kahden viimeisen numeron manipuloimisen. Sillä istuntojen välissä numerot kulkivat 67-74. Kuvassa olevasta "Add"-painikkeesta pääsi lisäämään payloadin.

![payload](https://github.com/jjenska/PenTest/assets/105623785/8b2311d0-d81e-464e-a943-14817a7d7a30)

Tässä tapauksessa valitsin valikosta "Payload type" -> "Numbers".

![numbers](https://github.com/jjenska/PenTest/assets/105623785/441fc1ac-81d3-45d7-be17-402c32f0d286)

Sen jälkeen asetin arvot mistä mihin, eli tässä tapauksessa 67 -> 74. Step oli automaattisesti 1, eli noustaan yhdellä ylöspäin. Kun arvot oli asetettu oikein, klikkasin oikealta ylhäältä "Start attack".

![startattack](https://github.com/jjenska/PenTest/assets/105623785/b5590fa3-09eb-48e8-bf94-0c2f0090de1d)

Tämän jälkeen Burp kävi jokaisen arvon läpi. Tämä tehtävä ei mennyt suinkaan ensimmäisellä yrittämällä läpi, vaan jouduin kokeilemaan useampaa tokenia. Monen yrityksen jälkeen kuitenkin onnistuin.

![donewebgoat1](https://github.com/jjenska/PenTest/assets/105623785/3d402d8c-3a93-4fe2-93f5-ca21c88befe0)

Tämä oli erittäin mielenkiintoinen tehtävä, ja opin mielestäni runsaasti, vaikka en ratkaissut sitä omatoimisesti.

#### Insecure Direct Object References (4)

Tehtävän alussa täytyi kirjautua sisään valmiiksi annetulla tunnuksella "tom" ja heikolla salasanalla "cat".

![tomcat](https://github.com/jjenska/PenTest/assets/105623785/08498068-5368-4172-914f-687fc296b412)

Seuraavassa vaiheessa olin kirjautuneena sisään, ja kehotettiin tarkastelemaan, mitä attribuutteja käyttäjältä löytyy klikkaamalla "View Profile". Verkkosivu näytti nimen, värin ja koon. 

![tomcat2](https://github.com/jjenska/PenTest/assets/105623785/74da66a9-b64b-4ad8-a0e7-67fe478302ee)

Osa datasta ei tule näkyviin verkkosivulle, vaan se löytyy HTTP-pyynnön vastauksesta usein "as raw data". Täytyi siis käyttää Burp:a apuna pyynnön tarkasteluun, joten klikkasin profiilia uudelleen ja etsin Burp:sta pyynnön "GET", joka viittaa polkuun "profile".

![tomcat3](https://github.com/jjenska/PenTest/assets/105623785/b246de0d-4c6b-4d47-8b84-eae9a81a3d88)

Kuten kuvasta näkyy, käyttäjälle oli määritelty 3 muun attribuutin lisäksi rooli (role: 3) ja id (userId: 2342384). Kun nämä kaksi tietoa (role, userId) lisäsi tekstinsyöttökenttään, osio tehtävästä ratkesi. Roolista voisi päätellä, että Tom ei ole välttämättä admin, koska usein alhaisin numero kuvastaa pääkäyttäjän tasoa. Seuraavaan osioon siirryttäessä, oli pääteltynä, että sovellus mukailee RESTful tyyppistä polkua. Koska käyttövaltuudet jaetaan rooleihin, käyttäjän oma istunto/tunnistautumistieto ei kerro, kenen käyttäjätietoa halutaan katsella. Profiilia ei siis voi tarkastella pelkästään polulla ```/profile```. Tässä täytyi siis lisätä jokin tunniste polkuun, jolla Tom-käyttäjän profiili löytyy. 

![tomcat4](https://github.com/jjenska/PenTest/assets/105623785/caa87171-c59d-4a54-97ed-85d187a48734)

Vinkki oli löydettävissä aikaisemmasta GET-pyynnöstä, jossa näkyi polku ```/WebGoat/IDOR/profile```. Lisäsin tähän loppuun käyttäjän yksilöivän id:n, jonka avulla profiili löytyi, eli ```/WebGoat/IDOR/profile/2342384```. 

![tomcat06](https://github.com/jjenska/PenTest/assets/105623785/ed744c6c-c595-4bcf-a09a-988dfd7ec0ce)

Seuraavassa osiossa täytyi löytää jonkun toisen käyttäjän profiili muokkaamalla polkua. Koska Tom-käyttäjän id oli 2342384, lähdin muuttamaan sen viimeistä numeroa käsin. Tämä tapahtui Burp:ssa niin, että lähetin GET-pyynnön "repeater" (hiiren oikea -> send to repeater) nimiseen ominaisuuteen, jolla pystyin lähettämään muokatun pyynnön useita kertoja, ja tarkastelemaan vastausta. Kokeilin id:ksi käsin vaihtoehtoja 2342384-2342387. Vihdoin id:n 2342388 kohdalla tärppäsi, ja sain näkyviin Buffalo Bill:n tiedot:

![tomcat6](https://github.com/jjenska/PenTest/assets/105623785/d275d33e-241f-462f-9c56-a4521985bf81)

Tehtävään oli määritelty myös muokkausosuus, jossa Bill-käyttäjän roolia, ja väriä tulisi muuttaa. Viimeinen osio antoi vinkkejä pyynnöistä, minulle oli jo entuudestaan tuttua, että PUT-pyyntöä käytetään silloin, kun tietoja halutaan muokata. Päätin jatkaa Burp:n repeater-toiminolla, jotta pystyin peukaloimaan pyyntöä useasti. Lähdin ensin muokkaamaan polun ```PUT /WebGoat/IDOR/profile/2342388 HTTP/1.1```. Vinkkinä oli datatyyppi JSON, joka näkyi jo aikaisemmissa GET-pyynnöissä. Lisäsin saamani attribuutit pyynnön alas:

```json
{
"role": 1,
"color": "red",
"size": "large",
"name": "Buffalo Bill",
"userId": 2342388
}
```
Tämän jälkeen lähetin pyynnön, mutta sainkin vastaukseksi "Internal Server Error". En saanut mieleeni pyyntöä silmäilemällä, mikä voisi olla pielessä. Löysin *[videon](https://www.youtube.com/watch?v=K5BBP88kBjU)*, josta paljastuikin puuttuva osuus, eli "Content-Type" oli minulla virheellisesti muodossa "application/x-www-form-urlencoded". Tämän kun vaihtoi "application/json", pyyntöni meni läpi, ja sain ratkaistua tehtävän. Aluksi syötin kaikki attribuutit, mutta pelkkä role, color ja id olisi riittänyt. Kokeilin siis vielä molempia:

![tomcat7](https://github.com/jjenska/PenTest/assets/105623785/b20b710c-bc2d-4f87-a337-bf8310b96c5e)

![tomcat8](https://github.com/jjenska/PenTest/assets/105623785/4c0a8c7f-d62e-4bcf-b326-2df448b160f6)

#### Missing Function Level Access Control (3)

Tehtävä antoi vinkiksi, että vihjeitä eri toiminnallisuuksista voivat antaa HTML tai javascript kommentit, kommentoidut elementit tai piilotetut osiot esim. CSS luokissa. Tehtävässä täytyi etsiä kaksi piilotettua asiaa menu-valikosta, jotka voisivat kiinnostaa mahdollista hyökkääjää. Klikkasin siis valikon päällä suoraan hiiren oikealla ja "inspect", jotta sain lähdekoodin näkyviin. Div-tagien sisältä löytyi listaelementti, jonka luokkana oli "hidden-menu-item dropdown". Sieltä löytyikin 2 kiinnostavaa tietoa: Users ja Config. Nämä kun syötin kenttiin pääsin eteenpäin. 

![missing1](https://github.com/jjenska/PenTest/assets/105623785/ce9090c8-d03f-4e3b-a4f9-1ab8e41cc493)

Seuraavassa osiossa tarvitsi hyödyntää löydettyjä piilotettuja polkuja, joiden avulla saataisiin Jerry:n kryptografinen tiiviste (hash). Vinkkeinä oli aikaisemmin löydetyt polut. Kun klikkasi "show hints", vinkiksi annettiin, että pyyntö tarvitsee muuttaa GET-pyynnöksi.

![missing2](https://github.com/jjenska/PenTest/assets/105623785/3469ecc4-02bb-48b3-9574-86faa2255eb6)

Jotta löytäisi käyttäjän Jerry tiedot ylipäätään, tarvitsisi nähdä kaikki käyttäjät. Burp:ssa laitoin "intercept on", klikkasin WebGoat:n submit painiketta, ja siirsin POST-pyynnön repeater-toimintoon. Tämän jälkeen laitoin "intercept off". Kokeilin vaihtaa end-pointiksi "/access-control/users". Tämä antoi vastaukseksi "Unsupported Media Type", ja alhaalla "Accept: application/json". 

![missing3](https://github.com/jjenska/PenTest/assets/105623785/2df064a9-e604-48af-9c76-eef7336e31ab)

Rajatut kohdat viittasivat siihen, että "Content-Type" täytyi muuttaa. Tässä vaiheessa muutin pyyntöni GET-pyynnöksi, ja muokkasin oikean sisältötyypin "application/json". Tämä tuotti tulosta, ja sain näkyviin 3 käyttäjää, sekä tiivisteen. Jerryn kohdalla rooli admin oli "true". Syötettyäni saamani tiivisteen sille kuuluvaan kenttään, osio ratkesi. 

![missing4](https://github.com/jjenska/PenTest/assets/105623785/c82159e0-dc22-4ca3-a2d9-7733a4fb13ec)

Tehtävä jäi osaltani tähän kohtaan, enkä saanut ratkaistua viimeistä osaa.

#### Spoofing an Authentication Cookie (1)

Tämä osio jäi valitettavasti tekemättä.

### n) (A7) Identity & Auth Failure (WebGoat 2023.4)
#### Authentication Bypasses (1)

Tämän tehtävän aloituksesta oli jäänyt kuvakaappaus nappaamatta. Tehtävän alussa oli kuitenkin *[esimerkki](https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass)*, jonka avulla käyttäjä oli onnistunut ohittamaan Paypalin varmennuksen. Palvelu oli lähettänyt tekstiviestin, mutta käyttäjä olikin päätynyt hyödyntämään vaihtoehtoista tapaa, eli turvakysymyksiä. Tämän pyynnön hän oli kaapannut välimiesproxylla ja poistanut parametrit kokonaan, jonka jälkeen kirjautuminen oli onnistunut.

Tehtävästä löytyi "Submit" painike, jota klikkasin, kun olin pysäyttänyt liikenteen Burp:lla. Pyynnön rivillä 18 näkyi kysymysparametrit "secQuestion0" ja "seqQuestion1", sekä metodi "verifyMethod=SEC_QUESTIONS":

![securityq1](https://github.com/jjenska/PenTest/assets/105623785/485f75fc-f816-42b4-8503-a5fab1e0995f)

Ensimmäinen testini oli poistaa molemmat parametrit, kuten esimerkissä. Tämä ei kuitenkaan tuottanut tulosta. Sen jälkeen poistin myös verifyMethodin, mutta vastaukseksi sain palvelimelta virheen, joka herjasi sen puuttumista. Tämän jälkeen lähdin kokeilemaan, mikäli parametrien secQuestion numeroita muuttamalla tapahtuisi jotain. Annoin niille myös arvot "test". Tämä näyttikin toimivan, en ehkä oikein ymmärtänyt täysin miksi. 

#### Insecure Login (1)

Tehtävän pohjustuksena oli, että kaikki arkaluontoinen lähetettävä data tulisi salata. Alla olevassa kuvassa näkyy, että tehtävässä piti klikata sisäänkirjautumispainiketta, ja kaapata samalla POST-pyyntö, jotta sitä voitaisiin tarkastella.

![insecure1](https://github.com/jjenska/PenTest/assets/105623785/040deba9-0e40-4411-875d-26b2b81b50e0)

Käytin apunani Burp:a, josta etsin oikean pyynnön. Käyttäjätunnus ja salasana näkyivät harvinaisen selvästi.

![insecure2](https://github.com/jjenska/PenTest/assets/105623785/c9e126a7-348a-4ed7-8948-8477f597da7c)

```
username: CaptainJack
password: BlackPearl
```

Palasin WebGoat:iin, lisäsin nämä tiedot kenttiin ja klikkasin "Submit". Näin tehtävä oli suoritettu:

![insecure3](https://github.com/jjenska/PenTest/assets/105623785/2170511d-9bda-42c4-90f1-eb6b28dc7a6a)

### o) (A10) Server-side Request Forgery (WebGoat 2023.4)
#### Server-Side Request Forgery (2)

Tehtävän ensimmäisessä vaiheessa kehotettiin muokkaamaan pyyntöä, jotta löytää Jerry:n. Laitoin Burp:ssa "intercept on" ja klikkasin painiketta "Steal the Cheese". Tämän jälkeen painikkeen alas pompahti animaatioista tutun Tom-kissan kuva. Pyyntö näytti tältä:

![ssrf1](https://github.com/jjenska/PenTest/assets/105623785/a192a627-8c5f-4be1-ad20-66f75388bff4)

Rehellisesti mietin hetken aikaa, että mitäs tässä haetaan. Aikani pohdittua, päätin muokata URL:n tiedostonimeä ```tom.png``` -> ```jerry.png```. Tämä tuottikin oikean lopputuloksen:

![ssrf2](https://github.com/jjenska/PenTest/assets/105623785/c557c63a-eac3-486e-a179-e927de5831a0)
![ssrf3](https://github.com/jjenska/PenTest/assets/105623785/c5bb6940-e892-4e7a-9679-c4f8231f7e8f)

Seuraavassa osiossa oli tarkoitus muuttaa HTTP-pyyntöä niin, että palvelin saa tiedon osoitteesta ```http://ifconfig.pro```.

![ssrf4](https://github.com/jjenska/PenTest/assets/105623785/4487e8b0-c2c8-49ec-bb87-e846d2630946)

Avasin taas Burp:n ja kaappasin kaiken liikenteen. Tämän jälkeen klikkasin "Try me" painiketta. Se avasi ruudulle kissan kuvan. POST-pyynnössä näkyi URL kuvatiedostoon ```url=images%Fcat.png```. Ohje tehtävään oli suoraviivainen, joten muutin polun suoraan muotoon ```url=http://ifconfig.pro```. Tällä sain ratkaistua tehtävän. Näissä esimerkeissä oli todennäköisesti syynä pyynnön lähettäminen ns. "raw datana", eikä sitä validoitu mitenkään. Palvelimella pitäisi olla myös nk. "whitelist", jossa on otettu huomioon, esim. mistä domaineista, lähteistä ja protokollista palvelin voi noutaa dataa.

### p) Client side (WebGoat 2023.4)
#### Bypass front-end restrictions (2)

Käyttäjillä on mahdollisuus muokata HTML-koodia, ja joskus myös skriptejä. Sovellukset, jotka vaativat tiettyjä kenttiä/lomakkeita, joihin käyttäjä syöttää tietoa, tulisi aina validoida myös palvelimella. Tässä tehtävässä verkkosivun lomakkeeseen oli kirjoitettu käyttäjää ohjaavat vaatimukset, millaisena data tulisi kenttiin syöttää. 

![frontend1](https://github.com/jjenska/PenTest/assets/105623785/43ce97aa-8b8d-4a84-bea0-ddb7b3dde630)

Esimerkiksi ensimmäisessä alasvetovalikossa oli ainoastaan 2 valittavaa vaihtoehtoa. Päätin ensin testata, miltä lomakkeen tiedot näyttävät, jos oletusvaihtoehtoja muutetaan. Laitoin ensimmäisen valikon tiedoksi "option 2", toiseksi "option2" ja checkboxin klikkasin pois kokonaan. Numeroista pudotin kaksi pois, eli "123". Viimeisen kohdan jätin entiselleen. Tämän jälkeen kaappasin liikenteen Burp:ssa ja klikkasin WebGoat:ssa "Submit". Pyyntöni tuli näkyviin näin:

![frontend2](https://github.com/jjenska/PenTest/assets/105623785/ea83d0d0-44a9-4730-8a91-903dbccdedfd)

Alhalla pyynnössä näkyivät painikkeiden nimet "select", "radio" jne. Checkboxia ei näkynyt ollenkaan, koska olin jättänyt sen tyhjäksi. Muokkasin lomaketta vielä niin, että checkboxikin on valittuna, ja nappasin pyynnön tarkasteluun. Muokkasin pyyntöä:

```js
// alkuperäinen:
select=option2&radio=option2&checkbox=on&shortInput=123&readOnlyInput=change
muokattu
// option 3:sta ei ollut olemassa, checkbox tyhjänä ei lähetä mitään, 1234567 ylitti viiden rajan, testin oli tarkoitus olla read only
select=option3&radio=option3&checkbox=&shortInput=1234567&readOnlyInput=testi
```

Lähetettyäni pyynnön sain vastaukseksi osiosta: suoritettu. Kaikki "säännöt" pystyi siis kiertämään manipuloimalla pyyntöä. 

![frontend3](https://github.com/jjenska/PenTest/assets/105623785/91edca7c-22d7-4a0f-8861-44e38f209194)

Toisessa osiossa kentille oli annettu raja-arvot, mitä numeroita tai merkkejä niihin voisi asettaa. 

![frontend4](https://github.com/jjenska/PenTest/assets/105623785/dd74f130-85b3-4f2a-96ab-a98367e662d0)

En muokannut kenttiä vielä tässä vaiheessa, vaan aloitin liikenteen kaappaamisen Burp:ssa, ja klikkasin "Submit". Näin sain näkyviin kaikkien kenttien attribuutit ja arvot. Kuten alhaalla kuvassa näkyy, päätin lisätä jokaiseen kohtaan merkin vaatimusten ulkopuolelta. Kaikkiin muihin kohtiin se oli kirjain "d", paitsi kenttään 3 "'s", jossa ainoastaan kirjaimet, numerot ja välilyönnit olivat sallittuja.

![frontend5](https://github.com/jjenska/PenTest/assets/105623785/cd0efaa1-df29-4484-a276-3c1b53606fee)

Pyynnön muokkaus onnistui, kuvassa alhaalla tosin näkyy vastauksen vieressä alkuperäinen pyyntö.

![frontend6](https://github.com/jjenska/PenTest/assets/105623785/fba7c0bc-504a-4961-886a-924aa987db3b)

Tehtyäni tehtävät, suljin WebGoat:n termonaalista ```ctrl``` ```c```.


## Lähteet:

[OWASP - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)

[OWASP - Serve-Side Request Forgery](https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/)

[Portswigger - Access Control](https://portswigger.net/web-security/access-control)

[Portswigger - Server-side Request Forgery](https://portswigger.net/web-security/ssrf)

[Tero Karvinen - h4 Totally Legit Certificate](https://terokarvinen.com/2023/eettinen-hakkerointi-2023/#h4-totally-legit-sertificate)

https://www.youtube.com/watch?v=K5BBP88kBjU
