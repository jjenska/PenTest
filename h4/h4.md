# h4 Totally Legit Certificate

Tehtävien tekemiseen käytettiin pöytäkonetta:

- Prosessori: AMD Ryzen 5 3600 6-Core Processor 3.59 GHz
- Kovalevy: 256 GB M.2 SSD, 512 GB SSD
- Muisti: 32GB RAM
- Käyttöjärjestelmä: Windows 10 Pro
- VirtualBox

Lisäksi virtuaalikonetta: Kali Linux (valmis paketti, oletusasetuksilla)

Tarkemmat tehtävänannot osoitteessa: *[terokarvinen.com](https://terokarvinen.com/2023/eettinen-hakkerointi-2023/#h4-totally-legit-sertificate)*

## x) Lue/katso ja tiivistä.

OWASP 2021: OWASP Top 10:2021: A01:2021 – Broken Access Control (IDOR ja path traversal ovat osa tätä)
- periaatteena, että käyttäjät eivät voi toimia käyttöoikeuksiensa ulkopuolella
- epäonnistuminen voi johtaa luvattomaan tiedonsaantiin, tiedon muokkaamiseen tai tuhoamiseen, tai liiketoimintaan liittyvien toimintojen suorittamiseen ilman valtuutusta
- tyypillisiä haavoittuvuuksia mm. toimintaperiaatteen laiminlyöminen (käyttäjille ei jaettu rooleja, vaan laajemmat oikeudet automaattisesti kaikilla), oikeuksien sivuuttaminen muokkaamalla esim. URL:a (parametrien peukalointi)
- muutama esimerkki, miten ehkäistä:
    - sisäänpääsyn valvonnan tekniikoiden toteutus ja hyödyntäminen uudelleen verkkosovelluksen koko elinkaaren aikana
    - verkkopalvelimen hakemistolistausten estäminen
    - varmistus, että versionhallinta (esim. .git) ja varmuuskopiointi ei löydy verkkopalvelun juuresta (root)
    - rajapinnan pyyntöjen määrän rajoitus

*[OWASP - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)*

OWASP 2021: OWASP Top 10:2021: A10:2021 – Server-Side Request Forgery (SSRF)
- tapahtuu, kun verkkosovellus noutaa resursseja etälähteestä validoimatta käyttäjän syöttämää URL:a\
    &rarr; mahdollistaa hyökkääjän pakottamaan sovelluksen lähettämään tekaistun pyynnön odottamattomaan kohteeseen, vaikka käytössä olisi palomuuri tai VPN
- muutama esimerkki, miten ehkäistä:
    - verkkokerroksessa esim. verkkojen segmentointi erillisiksi, jotta vapaata liikkumista voidaan estää jonkun sisään murtautuessa
    - palomuurilla rajattu kaikki ulkopuolinen verkkoliikenne, pakollista sisäverkossa tapahtuvaa liikennettä lukuunottamatta
    - sovelluskerroksessa kaiken asiakasohjelman syöttödatan siistiminen ja validoiminen
    - HTTP uudelleenohjausten estäminen

*[OWASP - Serve-Side Request Forgery](https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/)*

PortSwigger Academy:

Access control vulnerabilities and privilege escalation (IDOR on osa tätä):
- määrittelee, mikäli käyttäjällä on oikeus aikomansa toiminnon suorittamiseen
- voidaan jakaa eri alakategorioihin: vertical access controls, horizontal access controls ja context-dependent access controls
- pystysuorassa mallissa (vertical) pääsynhallinta arkaluontoisiin toimintoihin on rajattu tietyntyyppisille käyttäjille (pääkäyttäjä vs. tavallinen käyttäjä)\
  &rarr; haavoittuvuus: esim. `https://example.com/admin` polkuun onkin tavallisella käyttäjällä selailumahdollisuus\
  &rarr; haavoittuvuus: jotkut sovellukset määrittelevät käyttäjän roolin ja varastoivat sen piilotettuun kenttään, evästeeseen tai esiasetettuun kyselyparametriin, jota voi manipuloida: `https://example.com/login/home.jsp?admin=true`
- vaakasuorassa mallissa (horizontal) pääsynhallinta on rajattu tiettyjen käyttäjien resursseihin (esim. pankkisovellus, jossa rahaa voidaan siirtää vain omilta tileiltä, ei toisen käyttäjän)\
  &rarr; haavoittuvuus: käyttäjä voi katsella esim. omia pankkitietojaan käyttäen osoitetta `https://example.com/myaccount?id=123`, tässä `id` voidaan muuttaakin toisen käyttäjän arvoksi, jolla päästään sisään toisen pankkitietoihin
- asiayhteyteen sidotussa mallissa (context-dependent) pääsynhallinta on rajattu toiminallisuuksiin ja resursseihin, jotka perustuvat sovelluksen tilaan tai miten käyttäjä 
on vuorovaikutuksessa sen kanssa (esim. toimintojen tekeminen väärässä järjestyksessä ei onnistu, maksettua tuotetta ei pysty enää muokkaamaan)

*[Portswigger - Access Control](https://portswigger.net/web-security/access-control)*

Server-side template injection
- ...

Server-side request forgery (SSRF)
- tyypillisessä hyökkäyksessä hyökkääjä saattaa saada palvelimen luomaan yhteyden yrityksen infran sisäisiin palveluihin
- esim. kun verkkosivulta tehdään pyyntö tarkastella jonkin tuotteen varastosaldoa, palvelin lähettää pyyntöjä eri back-end REST rajapintoihin\
  &rarr; POST-pyyntöä voidaankin muokata `stockApi=http://localhost/admin`\
  &rarr; nyt pyyntö tulee paikalliselta koneelta, joten sovellus antaakin pääkäyttäjäoikeudet luotettuaan pyynnön lähteeseen\
  &rarr; jos paikallisen koneen pyyntöjä kohdellaan eri tavoin kuin normaaleja pyyntöjä, SSRF muuttuu kriittiseksi haavoittuvuudeksi

*[Portswigger - Server-side Request Forgery](https://portswigger.net/web-security/ssrf)*

Cross-site scripting
- ...

Karvinen 2020: Using New Webgoat 2023.4 to Try Web Hacking:
- sovellus, jolla voidaan harjoitella tunkeutumistestausta
- javan asennus mahdollistaa käytön, palomuurin asennus suojaksi
- Webgoat:n viimeisin versio löytyy GitHub:sta
- mikäli käytössä välimiesproxy, hyvä muuttaa portiksi joku toinen ennen käynnistämistä, esim. 8081

## a) Totally Legit Sertificate. Asenna OWASP ZAP, generoi CA-sertifikaatti ja asenna se selaimeesi. Laita ZAP proxyksi selaimeesi. Osoita, että hakupyynnöt ilmestyvät ZAP:n käyttöliittymään. (Ei toimi localhost:lla ilman Foxyproxya)

Maanantain tunnilla kävimme nopeasti Zap:n lataamisen läpi, mutta lukaisin *[getting started -ohjeita](https://www.zaproxy.org/getting-started/)* asennuksesta. Muistelin, että Zap vaatii Javan pyöriäkseen. Dokumentaatiosta selvisikin, että Linux:lle pitää asentaa Java +11 erikseen. Aloitin ensin kalin pakettien päivityksillä ja latasin Zap:n Linux paketin (Huomasin tosin myöhemmin Teron vinkit, jossa mainittiin cross-platformin olevan paras vaihtoehto).

![zap_package](https://github.com/jjenska/PenTest/assets/105623785/63777b0b-b81c-4a82-81b6-e2feb0dd587b)



Tämän jälkeen etsin ladattavaa Javaa tunnilla käydyn ohjeen perusteella:

```console
┌──(kali㉿kali)-[~]
└─$ apt-cache search jdk jre
default-jre - Standard Java or Java compatible Runtime
default-jre-headless - Standard Java or Java compatible Runtime (headless)
libanimal-sniffer-java - JDK/API verification tools
libhsdis0-fcml - HotSpot disassembler plugin using FCML
libreoffice - office productivity suite (metapackage)
openjdk-11-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-11-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-11-jre-zero - Alternative JVM for OpenJDK, using Zero
openjdk-17-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-17-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-17-jre-zero - Alternative JVM for OpenJDK, using Zero
openjdk-21-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-21-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-21-jre-zero - Alternative JVM for OpenJDK, using Zero
openjdk-22-jre - OpenJDK Java runtime, using Hotspot JIT
openjdk-22-jre-headless - OpenJDK Java runtime, using Hotspot JIT (headless)
openjdk-22-jre-zero - Alternative JVM for OpenJDK, using Zero
java-package - Utility for creating Java Debian packages
nvidia-openjdk-8-jre - Obsolete OpenJDK Java runtime, for NVIDIA applications
```

Valitsin openjdk-17-jre, joka käytiin läpi tunnin esimerkissäkin. Oletukseni oli, että se on vakaampi versio, kuin uudemmat 21/22.

```console
┌──(kali㉿kali)-[~]
└─$ sudo apt-get install openjdk-17-jre
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages were automatically installed and are no longer required:
  gcc-12-base libarmadillo11 libcanberra-gtk-module libcanberra-gtk0 libcbor0.8 libcodec2-1.1 libcurl3-nss
  libgcc-12-dev libgumbo1 libgupnp-igd-1.0-4 libjim0.81 libnfs13 libobjc-12-dev libstdc++-12-dev libtexluajit2
  libutf8proc2 libvpx7 lua-lpeg nss-plugin-pem python3-jdcal python3-pyminifier
Use 'sudo apt autoremove' to remove them.
The following additional packages will be installed:
  openjdk-17-jre-headless
Suggested packages:
  fonts-ipafont-gothic fonts-ipafont-mincho fonts-wqy-microhei | fonts-wqy-zenhei fonts-indic
The following packages will be upgraded:
  openjdk-17-jre openjdk-17-jre-headless
2 upgraded, 0 newly installed, 0 to remove and 63 not upgraded.
Need to get 43.9 MB of archives.
After this operation, 33.8 kB disk space will be freed.
Do you want to continue? [Y/n] y
Get:1 <http://http.kali.org/kali kali-rolling/main> amd64 openjdk-17-jre amd64 17.0.9+9-2 [184 kB]
Get:2 <http://http.kali.org/kali kali-rolling/main> amd64 openjdk-17-jre-headless amd64 17.0.9+9-2 [43.7 MB]
Fetched 43.9 MB in 2s (18.6 MB/s)                   
(Reading database ... 409376 files and directories currently installed.)
Preparing to unpack .../openjdk-17-jre_17.0.9+9-2_amd64.deb ...
Unpacking openjdk-17-jre:amd64 (17.0.9+9-2) over (17.0.9+9-1) ...
Preparing to unpack .../openjdk-17-jre-headless_17.0.9+9-2_amd64.deb ...
Unpacking openjdk-17-jre-headless:amd64 (17.0.9+9-2) over (17.0.9+9-1) ...
Setting up openjdk-17-jre-headless:amd64 (17.0.9+9-2) ...
Processing triggers for mailcap (3.70+nmu1) ...
# ...
# poistettu useita rivejä
```
Asennus todennäköisesti onnistui, koska en saanut virheitä. Sen jälkeen lähdin asentamaan ZAP:a. Piti hieman muistella tar-tiedoston purkamista, mutta h2 tehtävässä ffuf:n asennus tapahtui samalla kaavalla. Komennossa siis ```-x``` tarkoittaa ```execute```, eli suorita. ```-f``` taas määrittelee tiedoston (file), jonka tiedot lisätään viimeiseksi (ZAP_2.1.14.0_Linux.tar.gz).

```console
┌──(kali㉿kali)-[~/Downloads]
└─$ tar -xf ZAP_2.14.0_Linux.tar.gz 
┌──(kali㉿kali)-[~/Downloads]
└─$ ls
ZAP_2.14.0  ZAP_2.14.0_Linux.tar.gz
```
Loin vielä oman kansion Zap, jonka jälkeen siirsin purkamani tiedoston sinne.

```console
┌──(kali㉿kali)-[~/Downloads]
└─$ cd ..
┌──(kali㉿kali)-[~]
└─$ mkdir Zap 
┌──(kali㉿kali)-[~]
└─$ mv Downloads/ZAP_2.14.0 Zap 
```

Tämän jälkeen siirryin Zap-kansioon ja vilkaisin, mitä tiedostoja se sisältää. Päätin lukaista nopeasti README-tiedoston. Siellä oli tieto, että Zap voidaan käynnistää "zap.sh" tai esim. luoda graafinen pikakuvake sovellukselle. Testasin toimiiko ajo suoraan: ./zap.sh. Ohjelma avautui ruudulle, ja hetken ladattuaan avasi kysymysboksin: "Do you want to persist the ZAP session?". Dokumentaation mukaan Zap oletusarvoisesti tallentaa liikennettä levylle HSQLDB tietokantaan oletusnimellä ja sijainnilla. Mikäli istuntoa ei pidetä yllä (persist), tiedostot poistetaan, kun käyttäjä poistuu ZAP:sta. Valitsin "No, I do not want to persist this session at this moment in time", jota dokumentaatio suositteli näin alkuvaiheessa, kun käyttö on uutta. Tämän jälkeen "start".

Tämän jälkeen sain listan ZAP:n lisäosista ja mahdollisuuden päivittää niitä. Painoin kuitenkin tässä vaihessa "close". 

![addons](https://github.com/jjenska/PenTest/assets/105623785/1a86e1fc-07b2-4da1-b794-02f655ee48c1)

Sitten lähdin luomaan sertifikaattia. Valitsin ZAP:n ylävalikosta
 
"Tools" -> kirjoitin hakukenttään "certificate" -> löytyi välilehdeltä "Network" -> "Server Certificates" -> "Generate"

Tämä avasi uuden ikkunan, joka ilmoitti että Root CA on jo olemassa. Painoin kuitenkin, että haluan ylikirjoittaa nykyisen sertifikaatin. "Yes".

![certf](https://github.com/jjenska/PenTest/assets/105623785/7e44469c-422d-4234-8b89-b1bf62caba37)

Tämän jälkeen klikkasin "Save", ja valitsin hakemistostani kansion Zap, jonne tallensin "Save". 

![savecertf](https://github.com/jjenska/PenTest/assets/105623785/ec0ff7e6-a28b-46ca-b2ff-673fc299da65)


Vielä kaiken varmistuksena klikkasin "ok". Tämän jälkeen navigoin Firefoxiin, ja oikealta ylhäältä valikosta "Settings". Hakukenttään syötin "certificate", jonka jälkeen klikkasin "View Certificates".

![certfs](https://github.com/jjenska/PenTest/assets/105623785/001bc048-1e4b-4c7e-b8fc-40ef2deb648b)

Sieltä klikkasin "import" ja valitsin hakemiston, jossa tallentamani sertifikaatti sijaitsi. Sen jälkeen "Open". Tässä vaiheessa Firefox kysyi, että haluanko luottaa kyllä ensimmäiseen kohtaan.

![trust](https://github.com/jjenska/PenTest/assets/105623785/be1d03d8-a228-46a3-a3a0-6be4a206dd2b)


Tämän jälkeen sertifikaatti ilmestyi listalle, klikkasin vielä "ok.".

![certok](https://github.com/jjenska/PenTest/assets/105623785/4452c259-ac68-4cdf-8ecb-1fd87a193197)

Tämän jälkeen testasin sertifikaatin toiminnan avaamalla Firefoxin ja Googlen. Näytti täysin luotettavalta:

![toimii](https://github.com/jjenska/PenTest/assets/105623785/ee15ef35-af0b-45bb-a1b3-ab7e314b730f)

Kirjoitin Googleen hakusanaksi "kokeilu", jolla testasin listautuuko GET-pyyntö ZAP:iin. Liikenne näytti toimivan oikein.

<img src="https://github.com/jjenska/PenTest/assets/105623785/495b9971-2272-46ea-b1af-3299242cc1b7" width="600" height="300" />


```console

```

## b) Asenna FoxyProxy Standard Firefox Addon, ja lisää ZAP proxyksi siihen.

Avasin Firefoxin ja klikkasin oikealta ylhäältä lisäosien kuvaketta, ja hain hakusanalla foxyproxy. 

![foxyproxy](https://github.com/jjenska/PenTest/assets/105623785/d665fbaf-6c5f-4d0f-a2e2-d9a1d26b86e3)

Suosituksena löytyi Foxyproxy standard, joten klikkasin sen kohdalla "Add to Firefox". Kun klikkasi selaimen osoiterivin oikealla puolella, ylhäällä olevaa lisäosakuvaketta ja asetuspainiketta, sai kiinnitettyä foxyproxin osoitepalkkiin näkyviin. Sitten klikkasin foxyproxy-kuvaketta, josta "Options" -> "Add". Tunnilla käytiin asetukset pikaisesti läpi, mutta silmäilin vielä Sami Kulonpään aikaisemman kurssitoteutuksen *[ohjeita]([https://kulonpaa.com/?p=338](https://kulonpaa.com/?p=338))*.

![addfp](https://github.com/jjenska/PenTest/assets/105623785/c2f7aba6-1103-44c5-8ce6-2ce1eca790a4)

Proxyn tyyppinä oli valmiiksi "HTTP", annoin sen olla, koska tulevat tehtävät käsittelisivät verkkosovellushyökkäyksiä. Tyypin alle pystyi laittamaan joko IP-osoitteen tai nimipalvelujärjestelmän nimen, eli itse lisäsin vain "localhost" -nimellä. Portiksi määrittelin 8080, ja loput vaihtoehdot olivatkin vapaaehtoisia. Tämän jälkeen painoin "Save". Päätin kuitenkin lisätä proxyn nimeksi vielä ZAP, mikäli päätyisin käyttämään myös Burp Suite:a tehtävien teossa. Tämän jälkeen otin proxyn käyttöön:

![zapurls](https://github.com/jjenska/PenTest/assets/105623785/1b5c7fe3-0362-4952-be90-10a2f333f988)

## PortSwigger Labs. Ratkaise tehtävät. Selitä ratkaisusi: mitä palvelimella tapahtuu, mitä eri osat tekevät, miten hyökkäys löytyi, mistä vika johtuu.

### Insecure Direct Object Reference (IDOR)
#### c) Insecure direct object references

Ensimmäisessä tehtävässä oli tarkoitus katsella käyttäjän chat-logeja palvelimen tiedostoissa, ja saada ne haltuun käyttämällä staattista URL:a. Tehtävä meni aikalailla ZAP:n käyttöä harjoitellen, ja kuvakaappaukset eri vaiheista unohtuivat täysin. Tehtävässä kaappasin pyynnön ZAP:ssä samalla, kun klikkasin "live chat" välilehdeltä löytyvää "View transcript" painiketta. URL:sta paljastui "2.txt"-tiedosto. Tähän en pähkäiltyäni keksinyt itse ratkaisua, vaan jouduin vilkaisemaan tehtävänannosta polkua. Tiedoston numeroinnista olisi pitänyt tajuta, että kun manipuloi numeron 2 -> 1, saadaan kopio aikaisemmasta keskustelusta. Kun suoritin pyyntöön muokkauksen "1.txt", sain tiedostosta auki chatissä käydyn keskustelun, jossa Carlosin salasananvahvistustiedustelu vahvistettiin. 

![carlos](https://github.com/jjenska/PenTest/assets/105623785/610142eb-2e6d-4605-be0a-b2e85ab0e1b8)

Yritän päivittää tehtävän vielä uudelleen kuvien kanssa, jos ehdin.

### Path traversal
#### d) File path traversal, simple case

Tässä tehtävässä oli tarkoitus hyödyntää tiedostopolku-haavoittuvuutta, kun tarkastellaan tuotekuvia. Päämääränä oli päästä ```/etc/passwd``` hakemistoon. Aloitin labran kaappaamalla ZAP:lla HTTP-liikenteen. Sitten klikkasin sivulla olevan tuotteen lisätietoja, ja latasin avautuvan kuvan erilliseen välilehteen. ZAP:ssa GET-pyyntö näytti tältä:

![filepath](https://github.com/jjenska/PenTest/assets/105623785/9755e14b-1bdb-4a63-bfbc-81bb91364ac4)

Punainen nappula ylhäällä näytti, että pyyntö on pysäytettynä. Kuvan polussa näkyi ```image?filename=26.jpg```. Olin törmännyt kotitehtävässä h3 vastaavankaltaiseen esimerkkiin. Tiesin siis, että polkua voidaan manipuloida lisäämällä parametrin "filename" perään ```../../../etc/passwd```. Oletuspolku levylle talletetuissa kuvissa on ````/var/www/images```. Palauttaakseen kuvan, sovellus lisää tämän tiedostonimen tuohon oletuspolkuun, eli lukee tässä tapauksessa ```/var/www/images/26.jpg```. Loppuliitteessä ```../../../``` kuvastaa hakemistossa siirtymistä alhaalta ylöspäin juureen *([Portswigger- File Path Traversal](https://portswigger.net/web-security/file-path-traversal))*. Eli ensin images -> www -> var -> /, josta etc -> passwd.

![donefilepath](https://github.com/jjenska/PenTest/assets/105623785/8c85ef43-cbdf-48ac-a7a6-3c0ebe0fd456)

Tämän jälkeen klikkasin ZAP:ssä pysäytyspainikkeen vieressä olevaa "play" painiketta, joka ohjasi muokatun pyynnön eteenpäin, ja näin labra oli ratkaistu. Tehtävien teko päättyi tiistaina 14.11.

#### e) File path traversal, traversal sequences blocked with absolute path bypass

Jatkoin torstaina 16.11. siitä mihin olin jäänyt viimeksi. Vaihdoin välimiesproxyn Burb:iin ja kirjauduin Portswiggerin sivuille. Huomasin kuitenkin, että "Access the lab" painike oli hävinnyt kokonaan. Luulin ensin, että kyse on siitä, koska ratkaisin tehtävän jo, mutta se ei ilmestynytkään mihinkään labraan. 

![problem](https://github.com/jjenska/PenTest/assets/105623785/670a620d-7f91-4481-9f97-2cd5c4d91f3d)

Kokeilin avata sivuston eri selaimilla (Firefox, Chromium, Chrome), mutta sekään ei tuottanut tulosta. Tein myös toisen käyttäjätilin testiksi, mutta sama ongelma toistui. Löysin aikaisemman viestiketjun, jossa muillakin käyttäjillä oli ongelmia, mutta syy ei ollut selvinnyt. Päätin laittaa sivustolle sähköpostia, koska en löytäny mitään muuta tietoa. Tässä vaiheessa siirryin asentamaan WebGoat:a, jotta aikaa ei menisi hukkaan. Testasin uudelleen iltapäivällä, noin parin tunnin kuluttua kirjautua uudelleen, ja nyt painikkeet olivat palanneet. Sain myöhemmin sähköpostin, jossa ilmoitettiin labran olleen huollon alla, selvisi siis syykin.




#### f) File path traversal, traversal sequences stripped non-recursively

### Server Side Template Injection (SSTI)
#### g) Server-side template injection with information disclosure via user-supplied objects (Tämä on merkitty hieman vaikeammaksi, jätä viimeiseksi jos näyttää hankalalta)

### Server Side Request Forgery (SSRF)
#### h) Basic SSRF against the local server

### Cross Site Scripting (XSS)
#### i) Reflected XSS into HTML context with nothing encoded
#### j) Stored XSS into HTML context with nothing encoded

## k) Asenna Webgoat 2023.4. (Uusi versio, jossa on eri tehtäviä kuin vanhemmissa)

Asennuksen tein Tero Karvisen *[ohjeita](https://terokarvinen.com/2023/webgoat-2023-4-ethical-web-hacking/)* mukaillen. Palomuurin olin jo asentanut Kalille, joten testasin, että se on toiminnassa:

```console
┌──(kali㉿kali)-[~]
└─$ sudo ufw status    
Status: active
```

WebGoat:n vaatima Javakin oli tullut asennettua jo ZAP:n asennuksen yhteydessä, joten siirryin lataamaan uusimman WebGoat version *[GitHub:sta](https://github.com/WebGoat/WebGoat/releases/tag/v2023.4)*. Klikkasin vain pakettia, ja tarkistin, että se ilmestyi ladattuihin tiedostoihin.

![downloadwebgoat](https://github.com/jjenska/PenTest/assets/105623785/cdaeff4c-1a48-45c8-8576-8c912272350d)

Koska WebGoat on tarkoituksella haavoittuvainen sovellus, kytkin koneen irti internetistä ja testasin ```ping 8.8.8.8```, jotta yhteys on varmasti poikki. Päädyin myös käyttämään Burp Suite:a, koska olin testannut sitä jo h3-kotitehtävässä. Ilmainen versio vaikutti sisältävän riittävästi ominaisuuksia, ja käyttöliittymä oli jo osittain tuttu. Burp kuuntelee myös oletuksena porttia 8080, joten jouduin muuttamaan sen asetukset. Avasin Burp:n ja klikkasin oikealta ylhäältä "Settings" -> "Tools" -> "Proxy".

![burpproxy](https://github.com/jjenska/PenTest/assets/105623785/f1e44e80-62bc-4a76-acf3-2f3f21ee3a86)

Sen jälkeen loin vielä Foxyproxy:lle Burp-proxyn, jonka IP 127.0.0.1 ja portiksi 8888. Otin proxyn käyttöön.

kuva

Sitten siirryin käynnistämään WebGoat:n.

```console
┌──(kali㉿kali)-[~/Downloads]
└─$ java -Dfile.encoding=UTF-8 -Dwebgoat.port=8081 -Dwebwolf.port=9090 -jar webgoat-2023.4.jar
```
Ensimmäinen ```-Dfile.encoding=UTF-8``` oletettavasti määrittelee, millä merkistöllä java koodaa tiedostot? Seuraavat osat määrittelevät WebGoat:n ja WebWolf:n portit. Koska Zap oli minulla jo määritelty porttiin 8080, asetin WebGoat:lle portin 8081. WebWolf on *[OWASP:n mukaan](https://owasp.org/www-project-webgoat/)* erillinen verkkosovellus, joka imitoi hyökkääjän konetta. Se mahdollistaa erottamaan, mitä hyökättävällä verkkosivulla tapahtuu ja toiminnot, joita hyökkääjänä tarvitsee tehdä. Oletuksena se kuuntelee porttia 9090, mutta se oli myös määriteltävä WebGoat:n käynnistyksen yhteydessä. Komennon ajamisen jälkeen alkoi pitkä lista toimintoja:

```console
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
2023-11-16 12:18:20.472  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : Starting StartWebGoat v2023.4 using Java 17.0.9 on kali with PID 34706 (/home/kali/Downloads/webgoat-2023.4.jar started by kali in /home/kali/Downloads)
2023-11-16 12:18:20.477  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : No active profile set, falling back to 1 default profile: "default"
2023-11-16 12:18:20.966  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : Started StartWebGoat in 1.004 seconds (JVM running for 1.722)
    __          __       _        _____                   _
    \ \        / /      | |      / ____|                 | |
     \ \  /\  / /  ___  | |__   | |  __    ___     __ _  | |_
      \ \/  \/ /  / _ \ | '_ \  | | |_ |  / _ \   / _' | | __|
       \  /\  /  |  __/ | |_) | | |__| | | (_) | | (_| | | |_
        \/  \/    \___| |_.__/   \_____|  \___/   \__,_|  \__|

2023-11-16 12:18:21.180  INFO 34706 --- [           main] org.owasp.webgoat.server.StartWebGoat    : No active profile set, falling back to 1 default profile: "default"
2023-11-16 12:18:22.411  INFO 34706 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2023-11-16 12:18:22.500  INFO 34706 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 79 ms. Found 2 JPA repository interfaces.
# jatkuu usean rivin verran, jonka jälkeen ilmoitus: please browse to http://127.0.0.1:8081/WebGoat to get started...
```
Avasin Firefoxin, ja navigoin osoitteeseen ```localhost:8081/WebGoat```. Sain etusivun aukeamaan, ja ryhdyin luomaan itselleni käyttäjätunnukset. 

![webgoatlogin](https://github.com/jjenska/PenTest/assets/105623785/b9eefb0d-4e5b-4868-ae16-204607c57ae6)

Käyttäjätunnus oli aluksi ohjeiden mukaan liian lyhyt (väh. 6 merkkiä), joten muokkasin sen kuntoon, jotta pääsin kirjautumaan sisään.

![webgoatfront](https://github.com/jjenska/PenTest/assets/105623785/58269692-5fec-4c26-9b1e-9e1e70b2ebaa)


## Ratkaise WebGoat 2023.4:

### m) (A1) Broken Access Control (WebGoat 2023.4)
#### Hijack a session (1)

#### Insecure Direct Object References (4)

Tehtävän alussa täytyi kirjautua sisään valmiiksi annetulla tunnuksella "tom" ja heikolla salasanalla "cat".

![tomcat](https://github.com/jjenska/PenTest/assets/105623785/08498068-5368-4172-914f-687fc296b412)

Seuraavassa vaiheessa olin kirjautuneena sisään, ja kehotettiin tarkastelemaan, mitä attribuutteja käyttäjältä löytyy klikkaamalla "View Profile". Verkkosivu näytti nimen, värin ja koon. 

![tomcat2](https://github.com/jjenska/PenTest/assets/105623785/74da66a9-b64b-4ad8-a0e7-67fe478302ee)

Osa datasta ei tule näkyviin verkkosivulle, vaan se löytyy HTTP-pyynnön vastauksesta usein "as raw data". Täytyi siis käyttää Burp:a apuna pyynnön tarkasteluun, joten klikkasin profiilia uudelleen ja etsin Burp:sta pyynnön "GET", joka viittaa polkuun "profile".

![tomcat3](https://github.com/jjenska/PenTest/assets/105623785/b246de0d-4c6b-4d47-8b84-eae9a81a3d88)

Kuten kuvasta näkyy, käyttäjälle oli määritelty 3 muun attribuutin lisäksi rooli (role: 3) ja id (userId: 2342384). Kun nämä kaksi tietoa (role, userId) lisäsi tekstinsyöttökenttään, osio tehtävästä ratkesi. Roolista voisi päätellä, että Tom ei ole välttämättä admin, koska usein alhaisin numero kuvastaa pääkäyttäjän tasoa. Seuraavassa osiossa pääteltiin, että sovellus mukailee RESTful tyyppistä polkua. Koska käyttövaltuudet jaetaan rooleihin, käyttäjän oma istunto/tunnistautumistieto ei kerro, kenen käyttäjätietoa halutaan katsella. Profiilia ei siis voi tarkastella pelkäästään polulla ```/profile```. Tässä täytyi siis lisätä jokin tunniste polkuun, jolla Tom-käyttäjän profiili löytyy. 

![tomcat4](https://github.com/jjenska/PenTest/assets/105623785/caa87171-c59d-4a54-97ed-85d187a48734)

Vinkki oli löydettävissä aikaisemmasta GET-pyynnöstä, jossa näkyi polku ```/WebGoat/IDOR/profile```. Lisäsin tähän loppuun käyttäjän yksilöivän id:n, jonka avulla profiili löytyi, eli ```/WebGoat/IDOR/profile/2342384```. Seuraavassa osiossa täytyi löytää jonkun toisen käyttäjän profiili muokkaamalla polkua.

![tomcat06](https://github.com/jjenska/PenTest/assets/105623785/ed744c6c-c595-4bcf-a09a-988dfd7ec0ce)

Koska Tom-käyttäjän id oli 2342384, lähdin muuttamaan sen viimeistä numeroa käsin. Tämä tapahtui Burp:ssa niin, että lähetin GET-pyynnön "repeater" (hiiren oikea -> send to repeater) nimiseen ominaisuuteen, jolla pystyin lähettämään muokatun pyynnön useita kertoja, ja tarkastelemaan vastausta. Kokeilin id:ksi vaihtoehtoja 2342384-2342387. Vihdoin id:n 2342388 kohdalla tärppäsi, ja sain näkyviin Buffalo Bill:n tiedot:

![tomcat6](https://github.com/jjenska/PenTest/assets/105623785/d275d33e-241f-462f-9c56-a4521985bf81)

Tehtävään oli määritelty myös muokkausosuus, jossa Bill-käyttäjän roolia, ja väriä tulisi muuttaa. Viimeinen osio antoi vinkkejä pyynnöistä, minulle oli jo entuudestaan tuttua, että PUT käytetään silloin, kun tietoja halutaan muokata. Päätin jatkaa Burp:n repeater-toiminolla, jolla pystyin peukaloimaan pyyntöä useasti. Lähdin ensin muokkaamaan polun ```PUT /WebGoat/IDOR/profile/2342388 HTTP/1.1```. Vinkkinä oli datatyyppi JSON, joka näkyi jo aikaisemmissa GET-pyynnöissä. Lisäsin saamani attribuutit pyynnön alas:

```json
{
"role": 1,
"color": "red",
"size": "large",
"name": "Buffalo Bill",
"userId": 2342388
}
```
Tämän jälkeen lähetin pyynnön, mutta sainkin vastaukseksi "Internal Server Error". En saanut mieleeni pyyntöä silmäilemällä, mikä voisi olla pielessä. Löysin *[videon](https://www.youtube.com/watch?v=K5BBP88kBjU)*, josta paljastuikin puuttuva osuus, eli "Content-Type" oli minulla virheellisesti muodossa "application/x-www-form-urlencoded". Tämän kun vaihtoi "application/json", pyyntöni meni läpi, ja sain ratkaistua tehtävän. Aluksi syötin kaikki attribuutit, mutta pelkkä role, color ja id olisi riittänyt. Kokeilin siis vielä molempia:

![tomcat7](https://github.com/jjenska/PenTest/assets/105623785/b20b710c-bc2d-4f87-a337-bf8310b96c5e)

![tomcat8](https://github.com/jjenska/PenTest/assets/105623785/4c0a8c7f-d62e-4bcf-b326-2df448b160f6)

#### Missing Function Level Access Control (3)

Tehtävä antoi vinkiksi, että vihjeitä eri toiminnallisuuksista voivat antaa HTML tai javascript kommentit, kommentoidut elementit tai piilotetut osiot esim. CSS luokissa. Tehtävässä täytyi etsiä kaksi piilotettua asiaa menu-valikosta, jotka voisivat kiinnostaa mahdollista hyökkääjää. Klikkasin siis valikon päällä suoraan hiiren oikealla ja "inspect", jotta sain lähdekoodin näkyviin. Div-tagien sisältä löytyi listaelementti, jonka luokkana oli "hidden-menu-item dropdown". Sieltä löytyikin 2 kiinnostavaa tietoa Users ja Config. Nämä kun syötin kenttiin pääsin eteenpäin. 

![missing1](https://github.com/jjenska/PenTest/assets/105623785/ce9090c8-d03f-4e3b-a4f9-1ab8e41cc493)

Seuraavassa osiossa tarvitsi hyödyntää löydettyjä piilotettuja polkuja, joiden avulla saataisiin Jerry:n hash-koodi. Vinkkeinä oli aikaisemmin löydetyt polut. Kun klikkasi "show hints", vinkiksi annettiin, että pyyntö tarvitsee muuttaa GET-pyynnöksi.

![missing2](https://github.com/jjenska/PenTest/assets/105623785/3469ecc4-02bb-48b3-9574-86faa2255eb6)

Jotta löytäisi käyttäjän Jerry tiedot ylipäätään, tarvitsisi nähdä kaikki käyttäjät. Burp:ssa laitoin "intercept on", klikkasin WebGoat:n submit painiketta, ja siirsin POST-pyynnön repeater-toimintoon. Tämän jälkeen laitoin "intercept off". Kokeilin vaihtaa end-pointiksi "/access-control/users". Tämä antoi vastaukseksi "Unsupported Media Type", ja alhalla "Accept: application/json". 

![missing3](https://github.com/jjenska/PenTest/assets/105623785/2df064a9-e604-48af-9c76-eef7336e31ab)

Rajatut kohdat viittasivat siihen, että "Content-Type" täytyi muuttaa. Tässä vaiheessa muutin pyyntöni GET-pyynnöksi, ja muokkasin oikean sisältötyypin "application/json". Tämä tuotti tulosta, ja sain näkyviin 3 käyttäjää, sekä hash-koodin. Jerryn kohdalla rooli admin oli "true". Syötettyäni saamani hash:n kenttään, osio ratkesi. 

![missing4](https://github.com/jjenska/PenTest/assets/105623785/c82159e0-dc22-4ca3-a2d9-7733a4fb13ec)

Tehtävä jäi osaltani tähän kohtaan, en saanut ratkaistua viimeistä osaa.

#### Spoofing an Authentication Cookie (1)

Tämä osio jäi tekemättä.

### n) (A7) Identity & Auth Failure (WebGoat 2023.4)
#### Authentication Bypasses (1)

https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass

#### Insecure Login (1)


### o) (A10) Server-side Request Forgery (WebGoat 2023.4)
#### Server-Side Request Forgery (2)

### p) Client side (WebGoat 2023.4)
#### Bypass front-end restrictions (2)

Tehtyäni tehtävät, suljin WebGoat:n ```ctrl``` ```c```.


## Lähteet:

[OWASP - Broken Access Control](https://owasp.org/Top10/A01_2021-Broken_Access_Control/)

[OWASP - Serve-Side Request Forgery](https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/)

[Portswigger - Access Control](https://portswigger.net/web-security/access-control)

[Portswigger - Server-side Request Forgery](https://portswigger.net/web-security/ssrf)

[Tero Karvinen - h4 Totally Legit Certificate](https://terokarvinen.com/2023/eettinen-hakkerointi-2023/#h4-totally-legit-sertificate)

https://www.youtube.com/watch?v=K5BBP88kBjU
