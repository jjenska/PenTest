# h5 Injected Sequel

Tehtävien tekemiseen käytettiin pöytäkonetta:

- Prosessori: AMD Ryzen 5 3600 6-Core Processor 3.59 GHz
- Kovalevy: 256 GB M.2 SSD, 512 GB SSD
- Muisti: 32GB RAM
- Käyttöjärjestelmä: Windows 10 Pro
- VirtualBox

Lisäksi virtuaalikonetta: Kali Linux (valmis paketti, oletusasetuksilla)

Tarkemmat tehtävänannot osoitteessa: *[terokarvinen.com](https://terokarvinen.com/2023/eettinen-hakkerointi-2023/#h5-injected-sequel)*

## x) Lue/katso/kuuntele ja tiivistä.

Karvinen 2016: PostgreSQL Install and One Table Database – SQL CRUD tutorial for Ubuntu (kohdasta "Three line install" alkaen)

- asennus ```sudo apt-get install postgresql``` ja tietokannan käynnistys ```sudo systemctl start postgresql```
- tietokannan luominen omilla käyttäjätunnuksilla ```sudo -u postgres createdb käyttäjänimi```, käyttäjän luominen tietokantaan ```sudo -u postgres createuser käyttäjänimi```
- tietokannan avaaminen onnistuu komennolla ```psql```
- mikäli käyttämiseen tai komentoihin tarvitsee apua, käytä ```help```, poistumiseen ```q```
- ```CREATE TABLE``` taulun luomiseen, ```INSERT INTO``` arvojen lisäämiseen, ```SELECT``` haluttujen arvojen tarkasteluun, ```UPDATE``` arvojen päivittämiseen, ```DELETE``` tietueiden poistamiseen
- tauluille valittava aina pääavain (primary key), helpoin asettaa ```SERIAL```, jotta jokaiselle tietueelle annetaan uniikki avain automaattisesti järjestyksessä
  
*[Karvinen Tero - Postgresql Installation](https://terokarvinen.com/2016/03/05/postgresql-install-and-one-table-database-sql-crud-tutorial-for-ubuntu/)*

OWASP 2017: A1:2017-Injection

- melkein mikä tahansa data voi olla injektion "kuljettaja": ympäristömuuttujat, parametrit, ulkoiset ja sisäiset verkkopalvelut, kaikenlaiset käyttäjät
- haavoittuvuudet hyvinkin laajalle levinneitä: löytyy usein esim. SQL tai noSQL kyselyistä, OS komennoista, XML parsereista jne.
- vaikutukset: voi johtaa datan tuhoutumiseen, pilaantumiseen tai sen paljastumiseen valtuuksien ulkopuolisille osapuolille, vastuun menettämiseen tai pääsyn estämiseen
- sovellus on haavoittuvainen esim. kun:
-   - se ei validoi, filtteröi, tai siisti käyttäjän syöttämää dataa
    - dynaamiset haut tai parametrisoimattomien, asiayhteydettömien kutsujen "karkaamiset" tulkitsija käyttää suoraan
- muutama esimerkki miten voidaan ehkäistä:
    - turvallisen ohjelmointirajapinnan (API) käyttö, jolloin vältetään tulkin käyttö kokonaan, tai tarjotaan parametrisoitu rajapinta, tai muutetaan käyttäämään ORM-työkaluja
    - whitelist:n käyttö palvelinpuolen syötteen validoinnissa
- esimerkkihyökkäys: ```String q = "SELECT * FROM users WHERE userID='" + request.getParameter("id") + "'"```\
    &rarr; hyökkääjä muuttaa "id" parametrin arvoa selaimessa ```http://example.org/app/userView?id=' or '1'='1```\
    &rarr; muuttaa pyynnön merkitystä niin, että kaikki käyttäjä taulun tietueet palautetaan

*[OWASP - Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)*

PortSwigger Academy: SQL injection (luvut lukuunottamatta "Blind SQL injection")

- SQL injektio on haavoittuvuus, joka sallii käyttäjän kajoamisen kyselyihin, joita sovellus tekee tietokantaansa
- onnistuneen hyökkäyksen seurauksena voidaan saada arkaluontoista dataa, kuten salasanoja, luottokorttitietoja tai henkilökohtaisia käyttäjätietoja
- haavoittuvuuksia voidaan tunnistaa järjestelmällisillä testeillä jokaiseen sovelluksen sisääntuloon, eli syötetään:
    - yksittäinen hipsu ```'``` ja etsitään virheitä/poikkeavuuksia
    - boolean ehdot kuten ```OR 1=1``` ja ```OR 1=2```, ja tarkastellaan eroja sovelluksen vastauksissa
    - payloadeja, jotka käynnistävät viiveitä suoritettaessa SQL-kyselyn sisällä, ja tarkastellaan eroja vastausten vasteessa
    - välimiesproxyn käyttö
- yleisiä injektio esimerkkejä: piilotetun datan hakeminen, sovelluksen logiikan kumoaminen, UNION-hyökkäykset, blind SQL injektio\
    &rarr; esim. käyttäjä erkki kirjautuu sisään salasanalla esimerkki:\
    ```SELECT * FROM users WHERE username = 'erkki' AND password = 'esimerkki'```\
    &rarr; kommentoimalla salasanan pois, voidaan kiertää kirjautumislogiikka:\
    ```SELECT * FROM users WHERE username = 'admin'--' AND password = ''```, ```--``` merkki viittaa kommenttiin SQL-kielessä\
    &rarr; kysely palauttaa admin nimisen käyttäjän, joten hyökkääjä pääsee kirjautumaan sisään kyseisellä käyttäjänimellä

*[Portswigger - SQL Injection](https://portswigger.net/web-security/sql-injection)*

Vapaaehtoinen: Karvinen 2019: MitmProxy on Kali and Xubuntu – attack and testing (Nykyisin asennus 'sudo apt-get install mitmproxy')

*[Karvinen Tero - Mitmproxy on Kali and xUbuntu](https://terokarvinen.com/2019/05/22/mitmproxy-on-kali-and-xubuntu-attack-and-testing/?fromSearch=mitmproxy)*

## a) Tee uusi PostgreSQL-tietokanta ja demonstroi create, read, update, delete (CRUD).

Aloitin tietokannan asennuksen *[ohjeiden](https://terokarvinen.com/2016/03/05/postgresql-install-and-one-table-database-sql-crud-tutorial-for-ubuntu/)* mukaisesti:

```console
┌──(kali㉿kali)-[~]
└─$ sudo apt-get -y install postgresql
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages were automatically installed and are no longer required:
  gcc-12-base libarmadillo11 libcanberra-gtk-module libcanberra-gtk0 libcbor0.8 libcodec2-1.1 libcurl3-nss
  libgcc-12-dev libgumbo1 libgupnp-igd-1.0-4 libjim0.81 libnfs13 libobjc-12-dev libstdc++-12-dev
  libtexluajit2 libutf8proc2 libvpx7 lua-lpeg nss-plugin-pem python3-jdcal python3-pyminifier
Use 'sudo apt autoremove' to remove them.
The following additional packages will be installed:
  postgresql-client-common postgresql-common
# ....
# rivejä poistettu 
```
Tämän jälkeen käynnistin tietokannan.

```console
┌──(kali㉿kali)-[~]
└─$ sudo systemctl start postgresql
# vielä tarkistus, että päällä:
┌──(kali㉿kali)-[~]
└─$ sudo systemctl status postgresql
● postgresql.service - PostgreSQL RDBMS
     Loaded: loaded (/lib/systemd/system/postgresql.service; disabled; preset: disabled)
     Active: active (exited) since Tue 2023-11-21 20:11:01 EET; 48s ago
    Process: 7161 ExecStart=/bin/true (code=exited, status=0/SUCCESS)
   Main PID: 7161 (code=exited, status=0/SUCCESS)
        CPU: 1ms

Nov 21 20:11:01 kali systemd[1]: Starting postgresql.service - PostgreSQL RDBMS...
Nov 21 20:11:01 kali systemd[1]: Finished postgresql.service - PostgreSQL RDBMS.
```
Ryhtyessäni luomaan tietokantaa, sain virheilmoituksen:

```console
┌──(kali㉿kali)-[~]
└─$ sudo -u postgres createdb $(whoami)  
could not change directory to "/home/kali": Permission denied
```

Pienen pohdinnan jälkeen siirryin home-kansiosta juureen ja droppasin tietokannan. Se olisi saattanut toimia täysin normaalisti kyseisistä ilmoituksista huolimatta, mutta loin kuitenkin uuden:

```console
┌──(kali㉿kali)-[/]
└─$ sudo -u postgres drodb kali
┌──(kali㉿kali)-[/]
└─$ sudo -u postgres createdb $(whoami)
┌──(kali㉿kali)-[/]
└─$ sudo -u postgres createuser $(whoami)
```
Tällä kertaa ei tullut mitään huomautuksia, joten oletettavasti kaikki toimi toivotusti. Seuraava ongelma kuitenkin tuli vastaan, kun yritin luoda uutta taulua kyseiseen tietokantaan: 

```console
┌──(kali㉿kali)-[/]
└─$ psql         
psql (16.0 (Debian 16.0-2), server 15.4 (Debian 15.4-3))
Type "help" for help.

kali=> CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(200), address varchar(200));
ERROR:  permission denied for schema public
```

Löysin *[artikkelin](https://www.cybertec-postgresql.com/en/error-permission-denied-schema-public/)*, josta kävi ilmi, että PostgreSQL versioista 15 ylöspäin ainoastaan tietokannan omistajalla on oikeudet luoda public schemaan. Pohdin siis, voisiko tämä olla syynä. Ilmeisesti jo luomalleni käyttäjälle olisi pitänyt antaa laajemmat oikeudet. Löysin Youtubesta *[videon](https://www.youtube.com/watch?v=tducLYZzElo&t=272s)*, josta kävi ilmi, että PostgreSQL asentaa oletuksena käyttäjän "postgres". Ei mikään paras ohjevideo, mutta päätin kokeilla, jos onnistuisin tällä ohjeella. Kirjautuminen onnistui, sillä rivillä näkyi nyt käyttäjä ```postgres@kali```. Skippasin toistaiseksi oman käyttäjän luomisen, ja kokeilin luoda tietokannan suoraan postgres-käyttäjällä. Se näytti onnistuvan, kuten myös tietokantaan siirtyminen. Tarkistin yhteyden vielä komennolla ```\conninfo```. 

```console
┌──(kali㉿kali)-[/]
└─$ sudo -i -u postgres          
┏━(Message from Kali developers)
┃
┃ This is a minimal installation of Kali Linux, you likely
┃ want to install supplementary tools. Learn how:
┃ ⇒ https://www.kali.org/docs/troubleshooting/common-minimum-setup/
┃
┗━(Run: “touch ~/.hushlogin” to hide this message)
postgres@kali:~$ createdb testi
postgres@kali:~$ psql -d testi 
psql (16.0 (Debian 16.0-2), server 15.4 (Debian 15.4-3))
Type "help" for help.

testi=# \conninfo
You are connected to database "testi" as user "postgres" via socket in "/var/run/postgresql" at port "5432".
```
Tämän jälkeen loin ensimmäisen taulun, joka näytti tällä kertaa onnistuvan ilman virheitä.

```console
testi=# CREATE TABLE customers (id SERIAL PRIMARY KEY, name VARCHAR(200), phone VARCHAR(100));
CREATE TABLE
testi=# \d customers
                                    Table "public.customers"
 Column |          Type          | Collation | Nullable |                Default                
--------+------------------------+-----------+----------+---------------------------------------
 id     | integer                |           | not null | nextval('customers_id_seq'::regclass)
 name   | character varying(200) |           |          | 
 phone  | character varying(100) |           |          | 
Indexes:
    "customers_pkey" PRIMARY KEY, btree (id)
```

### INSERT

Taulun luomisen jälkeen syötin siihen ensimmäisen tietueen, eli nimeen arvon Matti, ja puhelinnumeroksi 040-1234567. Tämän jälkeen lisäsin tauluun vielä 2 riviä lisää.

```console
testi=# INSERT INTO customers (name, phone) VALUES ('Matti', '040-1234567');
INSERT 0 1
testi=# SELECT * FROM customers;
 id | name  |    phone    
----+-------+-------------
  1 | Matti | 040-1234567
(1 row)
```

### SELECT

Tarkasteltaessa kaikkia taulussa olevia tietueita, käytin SELECT-komentoa:

```console
testi=# SELECT * FROM customers;
 id | name  |    phone    
----+-------+-------------
  1 | Matti | 040-1234567
  2 | Mikko | 040-2345678
  3 | Maisa | 040-2345679
(3 rows)
```

### UPDATE

Kokeilin päivittää asiakkaan Matti puhelinnumeron, ja tarkistin päivitetyn taulun tiedot:

```console
testi=# UPDATE customers SET phone='050-1234567' WHERE phone='040-1234567';
UPDATE 1
testi=# SELECT * FROM customers;
 id | name  |    phone    
----+-------+-------------
  2 | Mikko | 040-2345678
  3 | Maisa | 040-2345679
  1 | Matti | 050-1234567
(3 rows)
```

### DELETE

Viimeisenä testinä vielä asiakkaan nimeltä Mikko poistaminen:

```console
testi=# DELETE FROM customers WHERE name='Mikko';
DELETE 1
testi=# SELECT * FROM customers;
 id | name  |    phone    
----+-------+-------------
  3 | Maisa | 040-2345679
  1 | Matti | 050-1234567
(2 rows)
```

## b) Kuvaile yksinkertainen SQL-injektio, ja demonstroi se omaan tietokantaasi psql-komennolla. Selitä, mikä osa on käyttäjän syötettä ja mikä valmiina ohjelmassa.

Yksinkertaisena esimerkkinä voisi olla verkkosovelluksen lomake, jossa asiakas täyttää oman nimensä lomakkeeseen. Ohjelmassa koodi voisi näyttää tältä:

```Java
String query = 'SELECT * FROM customers WHERE name= ' + customerName;
```
Muuttuja customerName keksitty nopeasti päästä, ei välttämättä paras. Tämä muuttuja siis luettaisiin lomakkeen vastaavasta arvosta nimi. Injektiona hyökkääjä voisi syöttää verkkosovelluksen lomakkeen nimi kohtaan ```' or 1=1--```. PostgreSQL puolella kysely näyttäisi siis tältä:

```sql
SELECT * FROM customers WHERE name=' ' OR 1=1.
```
Jälkimmäinen osuus toteutuu aina, joten kysely palauttaisi kaikkien käyttäjien nimet ja puhelinnumerot. Kyseisellä komennolla demonstroituna omaan customers tauluun:

```console
testi=# SELECT * FROM customers WHERE name='' OR 1=1;
 id | name  |    phone    
----+-------+-------------
  3 | Maisa | 040-2345679
  1 | Matti | 050-1234567
(2 rows)
```
## PortSwigger Labs

## c) Tämä harjoitus oli jo tehty, löytyy raportistani [h2](/h1/h1.md) kohdasta c)

## d) SQL injection vulnerability allowing login bypass

Tässä tehtävässä oli tarkoitus ohittaa administrator tunnuksilla sisäänkirjautuessa salasanan syöttäminen. Testasin ohittamista suoraan lomakkeeseen.

![d1](https://github.com/jjenska/PenTest/assets/105623785/3c326237-98a6-4d89-920c-e71fb19d05cb)

Käyttäjätunnuksen perään lisäsin kommenttia vastaavan syntaksin ```--```. Tämä siis kommentoi kyselystä koko salasanan pois. Salasana kenttään lisäsin hipsut ```''```. Pääsin sisään ohittamalla salasanan:

![d2](https://github.com/jjenska/PenTest/assets/105623785/fee12a1f-1bc7-419b-86d0-dd9169ddf665)


## e) SQL injection attack, querying the database type and version on Oracle

Tässä tehtävässä oli SQL injektio haavoittuvuus tuotekategorioiden filtteröinnissä. Tulosten saamiseen oli mahdollista tehdä ```UNION``` hyökkäys. Tarkistin vielä "hint" osuuden, koska jokainen tietokanta toimii hieman omalla syntaksilla. Osuudessa annettiin vinkit, miten Oraclen ```SELECT``` kysely toimii ja linkki cheat sheet:iin. Jokaisessa Oraclen SELECT kyselyssä täytyy aina tarkentaa, mistä taulusta tietoa haetaan. Mikäli ```UNION SELECT``` hyökkäys ei tee kyselyä tauluun, sen täytyy stilti sisältää ```FROM``` avainsana sekä olemassa oleva taulu. Oraclessa tällaisena voidaan käyttää oletusta ```DUAL``` *([Portswigger - querying database version oracle](https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-oracle))*.

Klikkasin labran auki ja etusivulla näkyi yläpalkissa eri kategorioiden nimiä. Tehtävässä piti etsiä käytetyn tietokannan tyyppi ja versionumero. Tarvitsin välimiesproxyn, jotta pyyntöä voisi manipuloida. Käytin Burp:a. Yritin ratkaista tehtävää lisäämällä ```GET /filter?category=``` perään UNION SELECT -lauseen, mutta sain vastaukseksi "Internal Server Error". Tässä vaiheessa oli pakko vilkaista tehtävän ratkaisua, koska ei ollut aavistustakaan, miten kuuluidi edetä. Ratkaisussa kehotettiin lisäämään payloadiksi ```'+UNION+SELECT+'abc','def'+FROM+dual--```, jotta voi ensin testata, että kysely palauttaa 2 saraketta. En ollut itse määritellyt selkeästi kahta saraketta kyselyyni. Uudella testillä sain HTTP statuksen 200.

![e1](https://github.com/jjenska/PenTest/assets/105623785/0aa444e4-944e-428b-a6b8-00f379ba1cb4)

Tarkistin myös ratkaisun payloadin, joka oli muodossa ```'+UNION+SELECT+BANNER,+NULL+FROM+v$version--```. Tämän tehtävän ratkaisu jäi hieman hämäräksi. En oikein ymmärtänyt, mistä olisi pitänyt keksiä tuo avainsana ```BANNER```?

## f) SQL injection attack, querying the database type and version on MySQL and Microsoft

Tehtävässä piti saada MySQL ja Microsoft tietokantojen verionumerot käyttämällä SQL-injektiota. Vinkiksi oli annettu cheat sheet. Vilkaisin siitä, että molemmissa versio haetaan ```SELECT @@version```. Avasin siis labran ja lähetin GET pyynön Burp:n repeater-toimintoon. Päätin lukaista Portswiggerin *[artikkelia](https://portswigger.net/web-security/sql-injection/union-attacks)* UNION hyökkäyksistä tarkemmin. Oletettavasti taulua ei tarvitsisi määritellä, kuten Oraclessa oli dual *([Portswigger - Examining the Database](https://portswigger.net/web-security/sql-injection/examining-the-database))*. Testasin injektiota lisäämällä kutsun perään '+UNION+SELECT+@@version#. Vastaukseksi sain kuitenkin "Internal Sever Error".

![f1](https://github.com/jjenska/PenTest/assets/105623785/96ae96f3-9263-4961-ac87-20a27a9b658d)

Tajusin, että minun olisi pitänyt määritellä version lisäksi vähintäänkin toinen arvo. *([Portswigger - Union Attacks](https://portswigger.net/web-security/sql-injection/union-attacks))*. Lisäsin polkuun arvon NULL. Tällä sain labran ratkaistua, versionumero oli 8.0.35-0Ubuntu0.20.1:

![f2](https://github.com/jjenska/PenTest/assets/105623785/893747d7-43f9-40ed-94cb-6cace683b60f)
![f3](https://github.com/jjenska/PenTest/assets/105623785/82027340-899e-49e5-b249-6cc747a85106)

Tajusin myös, että UNION injektion voisi aina testata kahden arvon avulla, jotta nähdään palauttaako kysely 2 saraketta.

## g) SQL injection attack, listing the database contents on non-Oracle databases

Tehtävässä oli haavoittuvuus samaisessa tuotekategoria filtterissä. Tällä kertaa täytyi käyttää UNION hyökkäystä tauluun, joka sisältää käyttäjänimet ja salasanat. Ensin täytyi määrittää taulun nimi, ja sarakkeiden määrä. Sen jälkeen oli tarkoitus saada kaikkien käyttäjien tiedot. Selvittääkseen labran, piti kirjatua sisään administrator käyttäjänä. Vinkiksi oli annettu vain cheat sheet. Testasin ensin haulla, saisinko näymään kaikki schemat ja taulut.

![g1](https://github.com/jjenska/PenTest/assets/105623785/8532b522-e4fb-4e13-a62a-f1d86db8cddf)

Kuten kuvassa näkyy, tuli kategorioiden jälkeen pitkä lista vaihtoehtoja. Löysin sieltä taulun ```pg_user```, ja päätin kokeilla sillä 'UNION+SELECT+NULL,username+FROM+pg_user--. Tämä palautti kuitenkin vain arvon "Peter". 

![g2](https://github.com/jjenska/PenTest/assets/105623785/ce8c21c3-2445-4475-9738-48048d360f28)

Pohdin, että users täytyy olla monikossa, joten kokeilin hakea kaikki taulut uudelleen, mikäli minulta oli mennyt jotain ohi. Tällä kertaa kokeilin laittaa ```'UNION+SELECT+table_name,NULL+FROM+information_schema.tables```, jotta ylimääräiset osat karsiutuvat pois. Lista oli pitkä, mutta uudella silmäilyllä sieltä löytyi ```users_hvruhl```. Tämä näytti paremmalta. Kokeilin hakea suoraan taulusta ```'UNION+SELECT+column_name, NULL+FROM+users_hvruhl```, se antoi kuitenkin tulokseksi "Internal Server Error". Hetken pyörittelyn jälkeen, oli pakko vilkaista labran ratkaisusta esimerkkiä. Kyselyssä täytyi tietysti käyttää koko polkua. Taulun hakumäärittely oli asetettu perään lisätyllä WHERE ehdolla: ```WHERE+table_name='users_hvruhl'```. Tällä sain käyttäjänimen ja salasanan näkymään:

![g3](https://github.com/jjenska/PenTest/assets/105623785/f43846f4-ca75-4677-9ea4-9f6079fbdddb)

Tämän jälkeen piti hyödyntää saatujen sarakkeiden arvoja sisäänkirjautumiseen:

![g4](https://github.com/jjenska/PenTest/assets/105623785/c3142b10-d2d8-47ad-8e75-816fe051d69e)
![g5](https://github.com/jjenska/PenTest/assets/105623785/cb6521ea-6e2b-402c-841b-9d37ea8bacba)

SQL-tietokannan laajemmasta käytöstä oli itselläni kulunut aikaa. Todennäköisesti jonkun testitietokannan käytöstä tässä samalla olisi ollut hyötyä. Olisin päässyt testaamaan laajemmin komentoja, ja näkemään tulokset, mitä kyselyt palauttavat. Tai sitten olisi pitänyt rakentaa tehtävään a) useampi taulu ja niiden välille riippuvuuksia.

## h) SQL injection UNION attack, determining the number of columns returned by the query

Tässä tehtävässä piti ensin määritellä kyselyn palauttamien sarakkeiden määrä. Sen jälkeen piti palauttaa kysely, joka palauttaa ylimääräisen rivin sisältäen null arvoja. Katsoin [dokumentaatioa](https://portswigger.net/web-security/sql-injection/union-attacks), ja siellä oli maininta, että tämä voidaan tehdä joko hyödyntämällä ```' ORDER BY nro--``` tai ```' UNION SELECT NULL--``` lisäämällä null arvojen määrää vastaamaan sarakkeiden määrää. Testasin UNION SELECT tekniikalla. Lisäsin ensin ainoastaan yhden null arvon:

![h1](https://github.com/jjenska/PenTest/assets/105623785/933bb54b-1c3e-4c55-9f54-bc226a6c6c3c)

Tästä seurasi "Internal Server Error", joten lisäsin toisen. Ei toiminut. Kolmannen arvon lisäyksen jälkeen pyyntö onnistui ja vastauksena HTTP status 200. Labra oli ratkaistu:

![h2](https://github.com/jjenska/PenTest/assets/105623785/3bd9077e-cfc8-4bf3-9859-9995427b252c)

## i) SQL injection UNION attack, retrieving data from other tables

Tehtävän tietokanta sisälsi taulun nimeltä users. Tässä täytyi käyttää UNION hyökkäystä, jonka avulla saisi kaikki käyttäjänimet ja salasanat. Tämän jälkeen tuli käyttää administrator tunnusta sisäänkirjautumiseen. Koska molempien sarakkeiden nimet (username, password), ja taulun nimi (users) oli annettu tehtävänannossa valmiiksi, kokeilin hakea:
```console
'UNION+SELECT+username,password+FROM+users--
```
Tämä antoi vastaukseksi 3 eri käyttäjän tunnukset (carlos, wiener ja administrator):

![i1](https://github.com/jjenska/PenTest/assets/105623785/3488c377-a04f-447d-8e34-46aeee05930c)

Pääsin kirjautumaan administrator tunnuksilla.

![i2](https://github.com/jjenska/PenTest/assets/105623785/83387567-3e29-4738-883d-9135410c7d60)

## j) SQL injection UNION attack, retrieving multiple values in a single column

Tässä tehtävässä oli tarkoitus saada useampia arvoja sarakkeesta, ketjuttamalla arvoja yhteen. [Cheat sheet:stä](https://portswigger.net/web-security/sql-injection/cheat-sheet) löytyi vinkki merkkijonojen ketjuttamiseen. Esim. Microsoftin  tietokannassa tämä tapahtuu ```'string'+'string'``` ja Oracle:n ```'string' || 'string'```. En ollut varma minkä tietokannan syntaksia tässä haettiin, päätin kokeilla ensimmäisenä Microsoftia. Tehtävänannossa oli kerrottu valmiiksi, että sarakkeita on 2kpl (username, password) ja taulun nimi on users. Ratkaisu ei toiminut ensimmäisellä yrityksellä:

![j1](https://github.com/jjenska/PenTest/assets/105623785/2d47b584-8f24-40e5-b901-94569ae3b6b6)

Testasin vielä lisätä molemmille merkkijonoille hipsut, mutta sama palvelimen virhe toistui. Todennäköisesti tämä oli osaamisen puutetta, eli virheellisesti syötetty syntaksi. Tämän jälkeen kokeilin cheat sheet:n Oracle esimerkkiä ```||```. Tämä ratkaisu näytti toimivan, joskin tuloste olisi ollut siistimpi, jos merkkijonot olisi erottanut välimerkillä. Tässä tapauksessa käyttäjänimet olivat kuitenkin selkeät, ja siten helposti eroteltavissa:

![j2](https://github.com/jjenska/PenTest/assets/105623785/0dadc26e-98bf-4cb4-b52c-68128febe9d0)

Huvikseni kokeilin vielä MySQL esimerkkiä ```CONCAT('string', 'string')```, ja se näytti toimivan yhtä hyvin:

![j3](https://github.com/jjenska/PenTest/assets/105623785/e4baba4e-606f-4f88-89f8-2dce6f7b0e5f)

Pienellä mieleen juolahtaneella testillä vielä siistimpi tulostus:

![j4](https://github.com/jjenska/PenTest/assets/105623785/f32965fa-d32f-47f5-abaa-40796c1c4054)

Ja toki vielä tunnuksilla sisäänkirjautuminen:

![j5](https://github.com/jjenska/PenTest/assets/105623785/b2f6a2b8-e618-4643-b35b-29097966aaf0)

# Lähteet

[Cybertec - Error permission denied](https://www.cybertec-postgresql.com/en/error-permission-denied-schema-public/)

[OWASP - Injection](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)

[Portswigger - SQL Injection](https://portswigger.net/web-security/sql-injection)

[Portswigger - SQL Injection: examining the database](https://portswigger.net/web-security/sql-injection/examining-the-database)

[Portswigger - SQL Injection: querying database version oracle](https://portswigger.net/web-security/sql-injection/examining-the-database/lab-querying-database-version-oracle)

[Portswigger - SQL Injection: union attacks](https://portswigger.net/web-security/sql-injection/union-attacks)

[Karvinen Tero - h5: Injected Sequel](https://terokarvinen.com/2023/eettinen-hakkerointi-2023/#h5-injected-sequel)

[Karvinen Tero - Mitmproxy on Kali and xUbuntu](https://terokarvinen.com/2019/05/22/mitmproxy-on-kali-and-xubuntu-attack-and-testing/?fromSearch=mitmproxy)

[Karvinen Tero - Postgresql Installation](https://terokarvinen.com/2016/03/05/postgresql-install-and-one-table-database-sql-crud-tutorial-for-ubuntu/)

[Youtube](https://www.youtube.com/watch?v=tducLYZzElo&t=272s)

